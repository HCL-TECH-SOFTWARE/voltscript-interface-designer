{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to VoltScript Interface Designer documentation","text":"<p>VoltScript Interface Designer (VSID) is an application for scaffolding VoltScript Extensions and Libraries, generating and updating starter code, and generating API documentation. VSID is an updated version of the LSX Toolkit, which was originally used to build LotusScript Extensions (LSX) for Notes and Domino. The original LSX Toolkit was updated so that it can be used to build VoltScript Extensions (VSE), and now it can also be used to document and build the starting code for VoltScript Script Libraries (VSS).</p> <ul> <li>VoltScript Extension (VSE) is a compiled module, written in C++, used to extend and add functionality to the VoltScript language. It's similar to the original LSXes provided for LotusScript.</li> <li>VoltScript Script library (VSS) is a script library, written in VoltScript, that has a set of classes, properties, methods, subs, and functions that can be used to enhance the VoltScript language. It's similar to the LotusScript Script Libraries used in Notes/Domino applications.</li> </ul> <p>To learn more, see topics in Topic guides.</p>"},{"location":"index.html#get-started","title":"Get started","text":"<ul> <li>Installation and setup</li> <li>Tutorial</li> <li>VoltScript Extension Samples</li> </ul>"},{"location":"index.html#whats-new","title":"What's new","text":"<p>For the latest release information about VoltScript Interface Designer, see What's new.</p>"},{"location":"index.html#how-the-documentation-is-organized","title":"How the documentation is organized","text":"<p>The documentation is based on the Di\u00e1taxis framework, which organizes documentation into the following modes to address users' documentation needs at different times and in different circumstances. Below shows an overview that guides you on where to look for needed information:</p> <p>Tutorials - Hands-on introduction on how to use VoltScript Interface Designer</p> <p>How-to guides - Practical step-by-step guides for performing tasks and operation</p> <p>Topic guides - High-level discussion and explanation of key topics and concepts in VoltScript Interface Designer</p> <p>References - Contain API documentation and test reports</p>"},{"location":"howto/index.html","title":"How-to guides","text":"<p>How-to guides instruct users in completing key goals and tasks related to VoltScript Interface Designer.  </p> <ul> <li>Use VoltScript Extension forms</li> <li>Use VoltScript Library forms</li> <li>Generate a VoltScript Extension</li> <li>Generate VoltScript Library code</li> <li>Generate API documentation</li> </ul>"},{"location":"howto/generateapi.html","title":"Generate API Documentation","text":"<p>After you have created project documents (either Script Extension, Script Library, or both) in your VoltScript Interface Designer (VSID) database, you can generate API documentation.  </p> <ol> <li>Open either the Script Extension Projects or the Script Library Projects view.</li> <li> <p>Select Actions \u2192 Generate \u2192 API Documentation.</p> <p></p> </li> <li> <p>When propmpted, enter the location where you would like to generate your API documentation, and then click OK.  </p> </li> <li> <p>A fully self-contained API documentation website (html, css, and javascript files) will be generated for your project in the location you specified. Depending on the number and complexity of your project documents this may take several minutes. Click OK when finished. </p> </li> <li> <p>Navigate to the location you specified and you will see a folder called apidoc.  Open that folder and double-click index.html.  </p> <p></p> <p>The API documentation website should launch in your default browser. </p> <p></p> </li> </ol> <p>Tip</p> <p>To publish this documentation to an external location, simply copy the apidoc folder including all its content and subfolders to the external site. </p>"},{"location":"howto/generatevse.html","title":"Generate a new VoltScript Extension","text":""},{"location":"howto/generatevse.html#introduction","title":"Introduction","text":"<p>VoltScript Extensions (VSE's) are native libraries for the VoltScript runtime, using the same well-known interface as earlier LotusScript Extensions (LSX's). As native code, they provide a way to write new classes and objects with more complex functionality or that use an existing third-party library. VoltScript Interface Designer (VSID) provides a way to describe the classes, properties, and methods of a VSE, and then generates C++ skeleton code based on the interface. This code uses modern CMake as its build system, allowing a developer to use a text editor or IDE of their choice to implement the design.</p>"},{"location":"howto/generatevse.html#voltscript-interface-designer","title":"VoltScript Interface Designer","text":"<p>VSID is distributed as a .ntf template and a .dll LSX for the Windows version of HCL Notes\u00ae 14.0. The template provides the form for designing a VSE or VoltScript library, with the .dll handling C++ code generation. The LSX will need to be registered first, so that it can be loaded by Notes.</p> <p>To get started designing your own VSE, you'll need to install and set up VSID. Detailed instructions are available in the tutorial section.</p> <ol> <li> <p>Extract the VSID template and .dll to a directory of your choice. This example will use the path <code>C:\\VSE\\</code>, your Notes data directory will work as well.</p> </li> <li> <p>Close Notes 14.0 if it is open. Register <code>vsidwizard.dll</code> in the Windows Registry. See Register the wizard DLL for more information.</p> <p>You can add the value yourself using the Registry Editor, or by running this command in an elevated command prompt, replacing <code>C:\\VSE\\vsidwizard.dll</code> with the full path to the DLL on your system:</p> <pre><code>REG ADD HKLM\\Software\\Lotus\\Components\\LotusScriptExtensions\\2.0 /v lsxwizard /t REG_SZ /d \"C:\\VSE\\vsidwizard.dll\" /f\n</code></pre> </li> <li> <p>Import the VSID template (<code>vsid.ntf</code>) into your Notes 14.0 client. An easy way is copying it into your Notes data directory.</p> </li> <li> <p>Open Notes 14.0 and create a new database, using \"VoltScript Interface Designer 1.0.0\" as the template. This example will use the name \"My First VSE\". The new database will be automatically opened to the \"Script Extension Projects\" view.</p> </li> <li> <p>Set the paths VSID will use when generating the VSE. In the top right corner of the view is a \"Setup\" button.</p> <p></p> <p>Click this to open the setup dialog. The second entry, \"VSE Target Directory\", is the directory the generated VSE files will be written to. You can set this to any directory you want - use the folder icon to the right of the text field to choose a folder, or enter the path directly. This example will use <code>C:\\VSE\\MyFirstVSE\\</code>.</p> <p></p> </li> </ol>"},{"location":"howto/generatevse.html#designing-generating-a-new-vse","title":"Designing &amp; generating a new VSE","text":"<p>VSID provides an interface for creating and modifying the programming interface for a VSE, such as the names and data types of properties and functions. We'll use it to create a simple VSE.</p> <ol> <li> <p>Make sure \"Script Extension Projects\" is selected from the left hand pane in VSID.</p> </li> <li> <p>Create a project. Along the top black bar of VSID, click the \"Project\" button to create and open a new project document. Fill in the fields for name, description, etc. as needed. \"Name\" is the name of the VSE, and will be referenced by any scripts that use it. For this example, we will set the name to \"MyFirstVSE\". Click \"Save &amp; Close\" at the top left of the document to save your changes and return to VSID.</p> </li> <li> <p>Create a class. With the project selected, click the \"Class\" button from the top of VSID to create and open a new class document in that project. Fill in the name field for the name - this will be used as the name of the class in the scripts. For this example, we will set the name to \"MyFirstClass\". Click \"Save &amp; Close\" at the top left of the document to save your changes and return to VSID.</p> </li> <li> <p>Give the class a property. With the class selected, click the \"Property\" button to create a new property. Properties are available to both VoltScript and C++, and can be used to expose data or provide a control. Set the name of the property, as well as its data type and optionally its default value when an instance of this class is created. For this example, we'll create a property with the name \"MyFirstProperty\", the data type \"Integer-Signed\", and the initial value \"123\".</p> <p></p> <p>Click \"Save &amp; Close\" at the top left of the document to save your changes and return to VSID.</p> </li> <li> <p>Give the class a method. With the class selected, click the \"Method\" button to create a new method. Methods can be called by VoltScript, and are generated as C++ methods. A method can be a function (has a return value) or a sub (no return value), and can optionally have a number of arguments with default values. For this example, we'll create a method with the name \"TestMethod\", the type \"Function\", and the return type \"Integer-Signed\". The default return value for this data type is 0.</p> <p></p> <p>Click \"Save &amp; Close\" at the top left of the document to save your changes and return to VSID.</p> </li> <li> <p>Press \"Generate Extension Files.\" Note that you will need to have a document in the \"Script Extension Projects\" selected to be able to run this. A dialog will pop up for the directory to generate files to, defalting to the one set in \"VSE Target Directory\" in the VSID Setup dialog. Review the path, changing it if needed, and press \"Ok\" to generate the files, along with the needed common header and source files.</p> <p></p> </li> </ol> <p>You can edit any document in VSID by double-clicking on it to open. Comment and Code Sample fields can be left empty, but will be referenced when the documentation is generated.</p>"},{"location":"howto/generatevse.html#building-and-testing-a-new-vse","title":"Building and testing a new VSE","text":"<p>After generating our C++ code, we can begin development. We'll start by building and testing the freshly generated VSE. All methods and functions will be given dummy values to allow the code to be compiled and loaded by VoltScript without editing any source first.</p> <ol> <li> <p>Build the VSE, either using the generated build script or another tool like Visual Studio Code. You will need a build environment with the 64-bit MSVC compiler and CMake available. If you have Visual Studio installed, a command prompt with the needed tools is in your start menu - search for \"x64 Native Tools Command Prompt for VS\". Navigate this command prompt to your generated VSE and run the generated build script: <code>build.bat --debug</code>. You can get help on using this script by running <code>build.bat --help</code>.</p> </li> <li> <p>Write a test VoltScript file that loads the VSE and interacts with it. For our example, here is a test script that interacts with our project, class, property, and method:</p> <pre><code>Option Public\nOption Declare\n\nUseVSE \"*MyFirstVSE\"\n\nSub Initialize\n\n    Dim hello as New MyFirstClass\n\n    Print \"Testing reading a VSE property:\"\n    Print hello.MyFirstProperty\n\n    Print \"Testing calling a VSE method:\"\n    Print hello.TestMethod()\n\nEnd Sub\n</code></pre> <p>For this example, this file will be located at <code>C:\\VSE\\MyFirstVSE\\hello.vss</code>.</p> </li> <li> <p>Run the script using VoltScript. VoltScript will need to be provided the path to the newly built VSE through <code>seti.ini</code>. The CMake build system will automatically generate a sample <code>seti.ini</code> with the path the built .dll in <code>bin/w64/</code>, as <code>seti-D.ini</code> for \"debug\" builds and <code>seti.ini</code> for \"release\" builds. You can pass the path to this <code>seti.ini</code> to VoltScript through the <code>--seti</code> option on the command line.</p> <p>For this example, we can run our test script against our earlier debug build by running VoltScript like this: <code>VoltScript.exe --seti bin\\w64\\seti-D.ini hello.vss</code>.</p> <p>The output of a successful test would look like this:</p> <pre><code>Testing reading a VSE property:\n 123\nTesting calling a VSE method:\n 0\n</code></pre> </li> </ol>"},{"location":"howto/generatevse.html#next-steps","title":"Next steps","text":"<p>Now that we have a functional VSE, we can use it as the starting point for further development. A development flow might look like this:</p> <ul> <li> <p>Implement the functionality of the VSE to provide a powerful library to your VoltScript projects. The most important files will be in the <code>src/VSEName</code> folder, where VSEName is the name of the project, like \"MyFirstVSE\". Files named after classes, like \"MyFirstClass.cpp\" and \"MyFirstClass.hpp\", will be populated with stub code for the methods and properties set in VSID.</p> </li> <li> <p>Add additional properties or methods and regenerate the VSE. Throughout the generated code are commented tag strings like <code>//{{LSX_AUTHOR_CODE_</code> and <code>//}}</code>. The code generation step will preserve any code between these tags, allowing existing implementations to be kept when the generation is run again.</p> </li> <li> <p>Use a source control tool like git to track changes and share your VSE with other developers.</p> </li> <li> <p>Review the generated <code>CMakeLists.txt</code> file and note how external libraries can be included.</p> </li> <li> <p>Test your VSE on your target platforms, such as the VoltScript Dev Container. The generated build system works on both Windows and Linux.</p> </li> </ul>"},{"location":"howto/generatevss.html","title":"Generate VoltScript Library code","text":"<p>Once you have created your library in your VoltScript Interface Designer (VSID) database, you're ready to generate your \"starting code\" so you can begin development in earnest on your library. </p> <ol> <li>Select your Project in the Script Library Projects view.</li> <li> <p>Select Actions \u2192 Generate \u2192 Library Source Code Stubs.</p> <p></p> </li> <li> <p>Enter the location where you like to generate your VSS code when prompted, and then click OK. </p> <p></p> </li> <li> <p>In the Export Templates? dialog, click No.  </p> <p></p> <p>Note</p> <p>Usually, you will not need to export the VSID templates. This is simply provided for troubleshooting. In case you're curious about how the templates are applied and used to generate your code, click Yes in the Export Templates? dialog.</p> </li> </ol>"},{"location":"howto/libraryforms.html","title":"Use VoltScript Library forms","text":"<p>This section gives you a basic introduction and details on how to use the various forms used when creating VoltScript Libraries (VSS). You can use these forms to create the foundation/\"skeleton\" for your library, and plan out your architecture before you write the code. This area can also be used to generate a set of API doc based on the signatures of your library.</p>"},{"location":"howto/libraryforms.html#project","title":"Project","text":"<p>The Project form is used to define the general information about your Library project. Here you can provide a summary and description, define if your project is public, etc. You can also define any other libraries (VSS), extensions (VSE), or other external files needed for your project.</p> <p></p>"},{"location":"howto/libraryforms.html#class","title":"Class","text":"<p>The Class form is used to define a Class for your Project. You specify the name of your Class, provide any helpful comments, and optionally some sample code on how to invoke the class. </p> <p></p> <p>If your class is derived from another class you can specify that in the Derivation area of the Class form.</p> <p></p> <p>Once you save your new Class the first time, it will automatically generate a New() Method doc under your Class document...</p> <p></p>"},{"location":"howto/libraryforms.html#method","title":"Method","text":"<p>The Method form is used to define the Method(s) for your Class. The Methods defined can either be a Function (does some work, returns a value) or Sub (does some work, does NOT return a value). For our example Invoice class we need to provide a way to open an existing Invoice as an object, so let's create an <code>OpenInvoice</code> method.</p> <p></p> <p>In the Method form you give your Method a name, indicate if it's a Sub or Function, and if it's a Function indicate the Data Type it returns. You can optionally provide a comment explaining it if you'd like.</p> <p>Most Methods will take one or more Arguments, and those can be defined in the Arguments section. In our example we need to provide an argument that allows an Invoice ID to be passed in.</p> <p>Then you can provide any expections is throws as well as some sample code if desired.</p>"},{"location":"howto/libraryforms.html#property","title":"Property","text":"<p>The Property form is used to define the Property(ies) for of your Class. In this form you provide the Name of your Property, any comments that explain the property, and the various attributes of the Property such as if it's Read-Only, Data Type, Initial Value, etc. And as always you can provide some Sample Code to show how to access the Property programmatically.</p> <p></p> <p>Now there are a couple of things you can create that are at the Project level, as \"Globals\", or globally available items. These are Variable and Type. Let's take a look at both of them.</p>"},{"location":"howto/libraryforms.html#variable","title":"Variable","text":"<p>The Variable form is used to define global variables in your project. You simply give your variable a name, add any optional helpful comments, and then define its attributes. A Variable can be a Constant, List, or Array, and you can define it as any Data Type.</p> <p>In our Invoice example let's create a global variable called InvoiceList. This will be a variable where we can store a list of Invoice objects, indexed by InvoiceID.</p> <p></p>"},{"location":"howto/libraryforms.html#type","title":"Type","text":"<p>The Type form is used to define custom data types for your project. For instance, you may want a complex data type to store multiple bits of metadata about an entity or object. In our example we may want an InvoiceData data type that stores things like CustomerName, InvoiceDate, and Total.</p> <p></p>"},{"location":"howto/extension/class.html","title":"Class","text":"<p>The Class form defines one or more Classes for your Extension project.  </p> <p></p> <p>The following sections describe the fields on the Class form.</p>"},{"location":"howto/extension/class.html#name","title":"Name","text":"<p>The class name is used in naming four VSE source files: </p> <ul> <li><code>&lt;cname&gt;.hpp</code></li> <li><code>&lt;cname&gt;.cpp</code></li> <li><code>i&lt;cname&gt;.cpp</code></li> <li><code>i&lt;cname&gt;.tab</code></li> </ul> <p>Note</p> <p>The name cannot be a LotusScript keyword or a C++ keyword.</p>"},{"location":"howto/extension/class.html#contained-by","title":"Contained By","text":"<p>The default value of this field is Default, which means that the class is not contained by any other class in the project.</p> <p>The drop-down list shows the names of classes already defined in the project. The class can be contained by any one of these. Instances of a contained class will be destroyed when the containing instance of the container class is destroyed. It's impossible to New a contained object from LotusScript. The container class must provide a method for instantiating a contained class.</p>"},{"location":"howto/extension/class.html#comment","title":"Comment","text":"<p>Enter any information that pertains to the Class as needed in this field.</p>"},{"location":"howto/extension/class.html#derivation","title":"Derivation","text":"<p>Choose Derived if this Class is derived from another class, or Base if this Class is not derived from another class. Base is the default option. </p> <p>If you choose Derived, the Derive From field appears. Select the Class from which your new class is derived. The drop-down list shows the names of classes already defined in the project, and the Notes back-end classes.</p> <p></p> <p>Note</p> <p>If the \"New\" method of the base class takes arguments, you must edit the \"New\" method of the derived class so that the first arguments match exactly, and in the same order, the arguments of the base class. You may add any other arguments after these. This is because the Wizard must generate the code to call the base class constructor, and this is the only way to know which arguments to pass to it.</p>"},{"location":"howto/extension/class.html#attributes","title":"Attributes","text":"<p>The following attributes may optionally be selected as needed:</p> <ul> <li>Collection</li> <li>Expanded</li> <li>Hide from IDE browser</li> <li>Unexposed \"new\" method</li> <li>Generate VSEVersion Property</li> </ul>"},{"location":"howto/extension/class.html#collection","title":"Collection","text":"<p>Select Collection to define the class as a collection class. A collection is a data structure similar to an array, which supports the <code>ForAll ... Next</code> syntax. Two drop-down lists become visible when this attribute is selected:</p> <ul> <li>Collection Data Type - The datatype of the objects to be collected. The drop-down list contains LotusScript datatypes, Domino Objects that are formerly called Notes back-end classes, and classes already defined in the project. You should select the datatype of the items in the collection.</li> <li>Collection Index Data Type - The datatype of the index into the collection. The drop-down list contains LotusScript datatypes. You should select the datatype of the index.</li> </ul> <p>Example </p> <p>If the collection index is a String, an element in the collection is accessed by a construct like this:</p> <pre><code>theCollection(\"Item1\")\n</code></pre> <p>If the index is an Integer, this is the form of the syntax:</p> <pre><code>theCollection(1)\n</code></pre>"},{"location":"howto/extension/class.html#expanded","title":"Expanded","text":"<p>An expanded class is one which allows the script writer to add properties on the fly. For example, declaring a class Expanded allows for running a script that contains code like this, even if the property <code>MyOwnProp</code> doesn't exist in the VSE:</p> <pre><code>MyClass.MyOwnProp = \"A Variant value\"\nPrint MyClass.MyOwnProp`\n</code></pre>"},{"location":"howto/extension/class.html#hide-from-ide-browser","title":"Hide from IDE browser","text":"<p>By default, VSE classes and their properties, methods, and events show up in the Browser (or Object References) pane of the Domino Designer Client under Notes Classes. Select this attribute if you do not wish this property to be visible in the Browser. </p> <p>Note</p> <p>Even if the property is hidden, it can still be accessed from a script if the script writer knows about its existence through other documentation.</p>"},{"location":"howto/extension/class.html#unexposed-new-method","title":"Unexposed \"new\" method","text":"<p>When you first save a Class document, a New method is automatically created, which is a constructor function for the class, representing it by a Function document. Every class needs a New method, whether or not the method is exposed, to users of the VSE in the class.</p> <p>You cannot give some other method the name \"New.\" With limitations, you can manipulate the definition of New that the Wizard generates:</p> <ul> <li>You cannot delete it.</li> <li>You cannot change its return value type, which is automatically the class itself. You cannot make the method a sub instead of a function.</li> <li>The Wizard creates the New function without arguments. You can add arguments\u00a0to the signature.</li> </ul> <p>The attributes on the Class form include Unexposed \"new\" method. If you select this attribute, the New method for the class will not be exposed to LotusScript. It will just be available internally in the class.</p> <p>There are two main uses for a class with the New method unexposed:</p> <ul> <li>As an abstract class: A class that cannot have any instances created. The purpose of such a class is to enable other classes to inherit from it.</li> <li>To force the end user to create class instances using a provided \"create\" or \"get\" function on a containing class, rather than the New in the class.</li> </ul> <p>The default is \"exposed\": The Unexposed \"new\" method is not selected by default. However, if you are creating a class and you specify that it's contained, the checkbox corresponding to this attribute is selected and you cannot change this option. New is always unexposed for a contained class.</p>"},{"location":"howto/extension/class.html#generate-vseversion-property","title":"Generate VSEVersion Property","text":"<p>Select this attribute to automatically generate a VSEVersion Property constructor document under the class.</p>"},{"location":"howto/extension/event.html","title":"Event","text":"<p>The Event form is used to define one or more Events for the Classes in your Extension project.</p> <p>When you create an Event for your class, it appears in the Projects view with OnEvent preceding it as shown:</p> <p></p> <p>The following sections describe the fields on the Event form.</p> <p></p>"},{"location":"howto/extension/event.html#name","title":"Name","text":"<p>The name of the event. An event name should not be a VoltScript, LotusScript, or a C++ keyword.</p>"},{"location":"howto/extension/event.html#comment","title":"Comment","text":"<p>Enter any information relevant to the Event in this field.</p>"},{"location":"howto/extension/event.html#arguments","title":"Arguments","text":"<p>The Arguments field of the Event form can be used to define up to ten arguments for your Event. The Arguments interface automatically detects when a new Argument Name and Argument Type have been provided, and displays a new row to accept a new argument should more be needed.</p> <p>The following are the parts of the Arguments interface.</p> <p></p> <ul> <li>Reorder - Use these arrows to move the arguments up or down in the list.</li> <li>Argument Name - Argument names should not be C++ keywords. Argument names can be LotusScript or VoltScript keywords, because they never appear in the script code.</li> <li>Argument Type - The drop-down list consists of VoltScript datatypes, Notes back-end classes, and classes already defined in the project.</li> <li> <p>Options - Allows you to choose the appropriate options for an argument. The available options are:</p> <ul> <li>Array - Select this option to indicate that the argument is an array of the specified Argument Type.</li> <li>By value - Select this option to indicate that the argument can be passed By Value. For scalars, the default is by value. For complex datatypes, such as String, Date, and Array (any kind of array), the default is by reference. Your VSE classes and Notes back-end classes are always passed by reference.</li> <li>Const - Select this option to indicate that the argument is a const.</li> <li>Optional - Select this option to indicate that the argument is optional.</li> </ul> <p>Note</p> <p>Not all combinations of options are possible or allowed</p> <p>The rules for how the Options affect each other are as follows:</p> <ul> <li>Scalar data types default to be passed By Value, but may be changed to by Ref </li> <li>Arrays must be By Ref</li> <li>Arrays may not be Optional </li> <li>Objects may not be Optional </li> <li>If an argument is marked Optional, all subsequent arguments must be Optional. This means all Object arguments must appear before any Optional arguments. </li> <li>Options should no longer be cleared when changing Data Type</li> <li>Arguments that are marked By Ref and Optional must also be Const.</li> <li>Only Arguments marked as Optional may have an Optional Value</li> <li>Currency and Date data types marked as Optional may not have an Optional Value</li> </ul> </li> <li> <p>Comment - Enter any optional comments you wish to provide about the argument in this field.</p> </li> </ul> <p>Tip</p> <p>To remove an argument from the list, clear the Argument Name field.</p>"},{"location":"howto/extension/forms.html","title":"Use VoltScript Extension forms","text":"<p>This section gives you a basic introduction and details on how to use the various forms used when creating VoltScript Extensions (VSE). You can use these forms to create the foundation or \"skeleton\" for your extension and plan out your architecture before you write the code. It can then generate the skeleton files for your C/C++ project. This area can also be used to generate a set of API docs based on the signatures of your extension.</p> <p>Refer to the following links to learn more about the forms and know how to use them. </p> <ul> <li>Project - The form used to define the overall project definition for your extension</li> <li>Class - The form used to define the classes in your extension</li> <li>Property - The form used to define the properties of the class</li> <li>Method - The form used to define the methods, such as subs and functions, of the class</li> <li>Event - The form used to define any events of the class</li> </ul>"},{"location":"howto/extension/method.html","title":"Method","text":"<p>The Method form is used to define one or more Methods (Subs or Functions) for the Classes in your Extension project.  </p> <p></p> <p>The following sections describe the fields on the Method form.</p>"},{"location":"howto/extension/method.html#name","title":"Name","text":"<p>The name of the method. A method name should not be a VoltScript, LotusScript, or a C++ keyword.</p>"},{"location":"howto/extension/method.html#attributes","title":"Attributes","text":"<p>The following attributes can be optionally set for your method:</p> <ul> <li>Hide from IDE Browser</li> <li>Method is const</li> </ul>"},{"location":"howto/extension/method.html#hide-from-ide-browser","title":"Hide from IDE browser","text":"<p>By default, VSE classes and their properties, methods, and events show up in the Browser or Object References pane of the Domino Designer Client, in the section headed Notes Classes. Select this attribute if you do not wish this property to be visible in the Browser.</p> <p>Note</p> <p>Even if the method is hidden in this way, it can still be accessed from a script if the script writer knows about its existence through other documentation.</p>"},{"location":"howto/extension/method.html#method-is-const","title":"Method is const","text":"<p>Select this attribute to generate the method as const in C++, so that the method can be called for class instances that are const.</p>"},{"location":"howto/extension/method.html#type","title":"Type","text":"<p>In this field, you can identity a Method document in the Extension Projects view as either a Function or a Sub by selecting the appropriate radio button.</p> <ul> <li>A Function is a method that has a return value. </li> <li>A Sub is a method with no return value. </li> </ul> <p>If the method is a Function, you must specify a Return Type, which is the Data Type returned by the method. You can also indicate if the method is returning an array of values by selecting the Array checkbox. </p>"},{"location":"howto/extension/method.html#comment","title":"Comment","text":"<p>Enter any information relevant to the Method in this field.</p>"},{"location":"howto/extension/method.html#arguments","title":"Arguments","text":"<p>The Arguments field of the Method form can be used to define up to ten arguments for your Method. The Arguments interface automatically detects when a new Argument Name and Argument Type have been provided and displays a new row to accept a new argument should more be needed.</p> <p>The following are the parts of the Arguments interface.</p> <p></p> <ul> <li>Reorder - Use these arrows to move the arguments up or down in the list.</li> <li>Argument Name - Argument names *should not be C++ keywords. Argument names can be LotusScript or VoltScript keywords because they never appear in the script code.</li> <li>Argument Type - The drop-down list consists of VoltScript datatypes, Notes back-end classes, and classes already defined in the project.</li> <li> <p>Options - Allows you to choose the appropriate options for an argument. The available options are: </p> <ul> <li>Array - Select this option to indicate that the argument is an array of the specified Argument Type.</li> <li>By value - Select this option to indicate that the argument can be passed By Value. For scalars, the default is by value. For complex datatypes, such as String, Date, and Array (any kind of array), the default is by reference. Your VSE classes and Notes back-end classes are always passed by reference.</li> <li>Const - Select this option to indicate that the argument is a const.</li> <li>Optional - Select this option to indicate that the argument is optional.</li> </ul> <p>Note</p> <p>Not all combinations of options are possible or allowed</p> <p>The rules for how the options affect each other are as follows:</p> <ul> <li>Scalar data types default to be passed By Value, but may be changed to by Ref </li> <li>Arrays must be By Ref</li> <li>Arrays may not be Optional </li> <li>Objects may not be Optional </li> <li>If an argument is marked Optional, all subsequent arguments must be Optional. This means all Object arguments must appear before any Optional arguments. </li> <li>Options should no longer be cleared when changing Data Type</li> <li>Arguments that are marked By Ref and Optional must also be Const.</li> <li>Only Arguments marked as Optional may have an Optional Value</li> <li>Currency and Date data types marked as Optional may not have an Optional Value</li> </ul> </li> <li> <p>Comment - Enter any optional comments you wish to provide about the argument in this field.</p> </li> </ul> <p>Tip</p> <p>To remove an argument from the list, clear the Argument Name field.</p>"},{"location":"howto/extension/project.html","title":"Project","text":"<p>The Project form is used to define the general information about your Extension project, including what platform or platforms it will work on, the character set used by the extension, the GUID for the project, and global constants.  </p> <p></p> <p>The following sections describe the fields on the Project form.</p>"},{"location":"howto/extension/project.html#name","title":"Name","text":"<p>The name you specify here has three roles. It becomes:</p> <ul> <li>the Project name in the Script Extension Projects view</li> <li>the <code>&lt;vse_name&gt;</code> in the VSE source-file directory <code>vse\\src\\&lt;vse_name&gt;</code> in the file system on your local drive</li> <li>the filename of the DLL or other shared library that's the built VSE</li> </ul>"},{"location":"howto/extension/project.html#summary-description","title":"Summary, Description","text":"<p>You can add an optional summary and description of your project in these fields. </p>"},{"location":"howto/extension/project.html#platforms","title":"Platforms","text":"<p>Select one or more platforms you wish to support with your Extension. You must select at least one platform. The results of choosing any platform are:</p> <ul> <li>a MAKE file and a <code>.def</code> file, or its equivalent, for each designated platform in the source-file directory</li> <li>platform-related conditional compilations within the C++ source files</li> </ul>"},{"location":"howto/extension/project.html#character-set","title":"Character Set","text":"<p>This field specifies how to represent strings passed into and out of the VSE. Choose the character set supported by your Extension. The default is UNICODE.</p>"},{"location":"howto/extension/project.html#base-ids","title":"Base IDs","text":"<p>On a Windows platform, the Wizard checks whether the Microsoft utility GUIDGEN or UUIDGEN is present on the machine before displaying the form. The Wizard invokes the utility to get a GUID and inserts the value in the Base ID GUID field when the form displays.</p>"},{"location":"howto/extension/project.html#global-constants","title":"Global Constants","text":"<p>The default is blank, meaning no constants. To define a global constant in the VSE, enter the name and value of your constant in the Constant and Value fields, and then click the Add ( + ) button. The value of your constant must be an Integer.</p> <p>To remove a constant, select the one you wish to remove, and then click the Subtract ( - ) button.</p> <p>To move a constant up or down in the list, select the constant you wish to move, and then use the Up ( \u25b2 ) or Down ( \u25bc ) button to relocate it accordingly.</p> <p></p>"},{"location":"howto/extension/project.html#overwrite-files","title":"Overwrite Files?","text":"<p>Select the checkbox if you wish to overwrite existing project files, such as MAK, SLN, when generated.</p>"},{"location":"howto/extension/property.html","title":"Property","text":"<p>The Property form is used to define one or more Properties for your Extension project.  </p> <p></p> <p>The following sections describe the fields on the Property form.</p>"},{"location":"howto/extension/property.html#name","title":"Name","text":"<p>The name of the property. A property name should not be a VoltScript, LotusScript, or a C++ keyword.</p>"},{"location":"howto/extension/property.html#comment","title":"Comment","text":"<p>Enter any information relevant to the Property in this field.</p>"},{"location":"howto/extension/property.html#attributes","title":"Attributes","text":"<p>The following Attributes may optionally be selected as needed: </p> <ul> <li>Read-only</li> <li>Hide from IDE browser</li> <li>Debugger causes side effect</li> <li>Property get is const</li> <li>Data Type and Initial Value</li> </ul>"},{"location":"howto/extension/property.html#read-only","title":"Read-only","text":"<p>Select this attribute to indicate that the value of this property may not be set from VoltScript. If a script tries to change the value of this property, it gets a syntax error indicating that the property is read-only.</p> <p>Also, no <code>Set&lt;property_name&gt;</code> function will be generated from this property, so the value may only be set from within its own class.</p>"},{"location":"howto/extension/property.html#hide-from-ide-browser","title":"Hide from IDE browser","text":"<p>By default, VSE classes and their properties, methods, and events show up in the Browser or Object References pane of the Domino Designer Client, in the section headed Notes Classes. Select this attribute if you do not want this property to be visible in the Browser.</p> <p>Note</p> <p>Even if the property is hidden in this way, it can still be accessed from a script if the script writer knows about its existence through other documentation.</p>"},{"location":"howto/extension/property.html#debugger-causes-side-effect","title":"Debugger causes side effect","text":"<p>The debugger in the Domino Designer Client shows the current value of the property by calling, indirectly, the <code>Get&lt;property_name&gt;</code> function in your VSE. If the <code>Get&lt;property_name&gt;</code> method does something like incrementing a counter, in addition to returning the value of the property, this may not be desirable behavior. If this is the case for your property, select this attribute to turn off debugging for this property.</p>"},{"location":"howto/extension/property.html#property-get-is-const","title":"Property get is const","text":"<p>This attribute refers to the way the code for the <code>Get&lt;property_name&gt;</code> method is generated in C++.</p> <p>Usually, this method can be declared const because it doesn't change any of the data values in your class. If this is the case, it's desirable to declare the method as const, because then it can be used by const instances of your class.</p> <p>Sometimes, however, this method can not be const. For example, if you need to do reference counting, or if you need to refresh a cache. In this situation, you should clear the checkbox corresponding to this attribute.</p>"},{"location":"howto/extension/property.html#data-type-and-initial-value","title":"Data Type and Initial Value","text":"<p>In the Attributes area, you can also specify the Data Type and Initial Value of this property. </p> <p>The Data Type field is where you select the data type of the objects to be collected. The drop-down list contains LotusScript datatypes, Domino Objects formerly called Notes back-end classes, and classes already defined in the project. You should select the datatype of the items in the collection.</p> <p>The Initial Value field refers to the value that the property should be initialized to in the constructor's member initialization list for the class. This field may be a set to a literal value, or to the name of one of the arguments that you have specified for your constructor (the New method). </p> <p>Example</p> <ul> <li>If you have specified a property named MaxSize, you could select an Initial Value of 10. Then, the code generated in the constructor's member initialization list will be m_MaxSize(10).</li> <li>If you have specified an argument to your constructor named max_size, you could set the Initial Value field to max_size. Then, the code generated in the constructor's member initialization list will be m_MaxSize(max_size).</li> </ul> <p>If the argument doesn't exist or the Initial Value is not of the correct datatype for the property, the generated C++ code will not compile.</p> <p>Note</p> <p>You can also specify if your property is an Array of the selected data type by selecting the Array checkbox.</p>"},{"location":"howto/library/class.html","title":"Class","text":"<p>The Class form is used to define a Class for your Project. You specify the name of your Class, provide any helpful comments, and optionally some sample code demonstrating how to invoke the class.  </p> <p></p> <p>When you save your new Class for the first time, a Method document for the class constructor (the \"New\" method) will be automatically generated.  </p> <p></p> <p>The following sections describe the fields on the Class form.</p>"},{"location":"howto/library/class.html#name","title":"Name","text":"<p>The name of the Class.  </p> <p>Note</p> <p>The name cannot be a LotusScript or C++ keyword.</p>"},{"location":"howto/library/class.html#comment","title":"Comment","text":"<p>Enter any information that pertains to the Class as needed in this field.</p>"},{"location":"howto/library/class.html#derivation","title":"Derivation","text":"<p>Choose Derived if this Class is derived from another class, or Base if this Class is not derived from another class. Base is the default option.  </p> <p>If you choose Derived, the Derive From field appears. Select the Class from which your new class is derived. The drop-down list shows the names of classes already defined in the project.</p> <p></p> <p>Note</p> <p>If the \"New\" method of the base class has differing arguments than the derived class, you must provide a value for the Extended Constructor field. The constructor signature of the base class will be visible to help provide you with a guide when typing in the Extended Constuctor. </p>"},{"location":"howto/library/forms.html","title":"Use VoltScript Library forms","text":"<p>This section gives you a basic introduction and details on how to use the various forms used when creating VoltScript Libraries (VSS). You can use these forms to create the foundation/\"skeleton\" for your library, and plan out your architecture before you write the code.  </p> <p>This area can also be used to generate a API documentation based on the signatures of your library.</p> <p>Refer to the following links to learn more about the forms and know how to use them.  </p> <ul> <li>Project - The form used to define the overall project definition for your library.</li> <li>Type - The form used to define a specific Type for the Project.</li> <li>Class - The form used to define the classes in your library.</li> <li>Property - The form used to define any Global-scope properties of the Project, or Local-scope variables of the class.</li> <li>Method - The form used to define the methods, such as subs and functions, of the class.</li> <li>Variable - The form used to define any Global-scope variables of the Project, or Local-scope variables for a specific class.</li> </ul>"},{"location":"howto/library/method.html","title":"Method","text":"<p>The Method form is used to define Method(s) for your Project Library or Class. The Methods defined can either be a Function (does some work, returns a value) or Sub (does some work, does NOT return a value).  For our example Invoice class we need to provide a way to open an existing Invoice as an object, so we have created an <code>OpenInvoice</code> method.</p> <p></p> <p>In the Method form you give your Method a name, indicate if it is a Sub or Function, and (for Functions) the Data Type returned. You can optionally provide a comment about the Method.  </p> <p>Most Methods will take one or more Arguments, and those can be defined in the Arguments section. In our example we need to provide an argument that allows an Invoice ID to be passed in.</p> <p>Then you can provide any known exceptions which can be thrown, and some sample code if desired.</p> <p>The following sections describe the fields on the Method form.</p>"},{"location":"howto/library/method.html#name","title":"Name","text":"<p>The name of the method. A method name should not be a VoltScript, LotusScript, or a C++ keyword.</p>"},{"location":"howto/library/method.html#type","title":"Type","text":"<p>In this field, you can identity a Method document in as either a Function or a Sub by selecting the appropriate radio button.</p> <ul> <li>A Function is a method that returns a value.  </li> <li>A Sub is a method with no return value.  </li> </ul> <p>If the method is a Function, you must specify a Return Type, which is the Data Type returned by the method. You can also indicate if the method is returning an array of values by selecting the Array checkbox.  </p>"},{"location":"howto/library/method.html#comment","title":"Comment","text":"<p>Enter any information relevant to the Method in this field.</p>"},{"location":"howto/library/method.html#arguments","title":"Arguments","text":"<p>The Arguments area of the Method form can be used to define up to ten arguments for your Method. The Arguments interface automatically detects when a new Argument Name and Argument Type have been provided and displays a new row to accept a new argument should more be needed.</p> <p>The following are the parts of the Arguments interface.</p> <p></p> <ul> <li>Reorder - Use these arrows to move the arguments up or down in the list.</li> <li>Argument Name - Argument names *should not be C++ keywords. Argument names can be LotusScript or VoltScript keywords because they never appear in the script code.</li> <li>Argument Type - The drop-down list consists of VoltScript datatypes, Notes back-end classes, and classes already defined in the project.</li> <li> <p>Options - Allows you to choose the appropriate options for an argument. The available options are:  </p> <ul> <li>List - Select this option to indicate that the argument is a List of the specified Argument Type.</li> <li>By value - Select this option to indicate that the argument can be passed By Value. For scalars, the default is by value. For complex datatypes, such as String, Date, and Array (any kind of array), the default is by reference. Your VSE classes and Notes back-end classes are always passed by reference.</li> </ul> </li> <li> <p>Comment - Enter any optional comments you wish to provide about the argument in this field.</p> </li> </ul> <p>Tip</p> <p>To remove an argument from the list, clear the Argument Name field.</p>"},{"location":"howto/library/project.html","title":"Project","text":"<p>The Project form is used to define the general information about your Library project. Here you can provide a summary and description, define if your project is public, etc. You can also define any other libraries (VSS), extensions (VSE), or other external files needed for your project.</p> <p></p> <p>The following sections describe the fields on the Project form.</p>"},{"location":"howto/library/project.html#name","title":"Name","text":"<p>This is the Name of your Project, and is how it will be found in the Script Library Projects view</p>"},{"location":"howto/library/project.html#summary-description","title":"Summary, Description","text":"<p>You can add an optional summary and description of your project in these fields.  </p>"},{"location":"howto/library/project.html#options","title":"Options","text":"<p>Select one or more options you wish to enable for your Library. Option Declare and Option Public are enabled by default.  </p>"},{"location":"howto/library/project.html#dependencies","title":"Dependencies","text":"<p>Here you can specify other code for which your project depends upon. You can define Libraries, Extensions, or any other External Files.  </p>"},{"location":"howto/library/property.html","title":"Property","text":"<p>The Property form is used to define any Property(ies) for a Project Library or a Class. With this form you provide the Name of your Property, any comments that explain the property, and the various attributes of the Property such as Read-Only, Data Type, Initial Value, etc. And as always you can provide some Sample Code to show how to interact with the Property programmatically.</p> <p></p> <p>Now there are a couple of things you can create that are at the Project level, as \"Globals\", or globally available items. These are Variable and Type.  </p> <p>The following sections describe the fields on the Property form.</p>"},{"location":"howto/library/property.html#name","title":"Name","text":"<p>The name of the property. A property name should not be a VoltScript, LotusScript, or a C++ keyword.</p>"},{"location":"howto/library/property.html#comment","title":"Comment","text":"<p>Enter any information relevant to the Property in this field.</p>"},{"location":"howto/library/property.html#attributes","title":"Attributes","text":"<p>The following Attributes may optionally be selected as needed: </p> <ul> <li>Read Only</li> <li>Static</li> <li>List</li> <li>Data Type and Initial Value</li> </ul>"},{"location":"howto/library/property.html#read-only","title":"Read-only","text":"<p>Select this attribute to indicate that the value of this property may not be set from VoltScript. If a script tries to change the value of this property, it gets a syntax error indicating that the property is read-only.</p> <p>Also, no <code>Set&lt;property_name&gt;</code> function will be generated from this property, so the value may only be set from within its own class.</p>"},{"location":"howto/library/property.html#static","title":"Static","text":"<p>Defines whether or not the Property's local variables are saved between calls.  </p>"},{"location":"howto/library/property.html#list","title":"List","text":"<p>Indicates that the property is a List instance of its Data Type.  </p>"},{"location":"howto/library/property.html#data-type-and-initial-value","title":"Data Type and Initial Value","text":"<p>In the Attributes area, you can specify the Data Type and Initial Value of the Property.</p> <p>The Data Type field is where you select the data type of the objects to be collected. The drop-down list contains LotusScript datatypes, Domino Objects formerly called Notes back-end classes, and classes already defined in the project. You should select the datatype of the items in the collection.</p> <p>The Initial Value field refers to the value that the property should be initialized to in the constructor's member initialization list for the class. This field may be a set to a literal value, or to the name of one of the arguments that you have specified for your constructor (the New method).  </p>"},{"location":"howto/library/type.html","title":"Type","text":"<p>The Type form is used to define custom data types for your project.  </p> <p>For instance, you may want a complex data type to store multiple bits of metadata about an entity or object. In our example we may want an InvoiceData data type that stores things like CustomerName, InvoiceDate, and Total.</p> <p></p>"},{"location":"howto/library/variable.html","title":"Variable","text":"<p>The Variable form is used to define global variables in your project. You simply give your variable a name, add any optional helpful comments, and then define its attributes. A Variable can be a Constant, List, or Array, and you can define it as any Data Type.</p> <p>In our Invoice example we have created a global variable called InvoiceList. This will be a variable where we can store a list of Invoice objects, indexed by InvoiceID.</p> <p></p>"},{"location":"references/index.html","title":"References","text":"<p>References provide technical references and descriptions for using VoltScript Interface Designer.</p>"},{"location":"references/index.html#whats-new","title":"What's new","text":"<p>Check the latest information about VoltScript Interface Designer.</p>"},{"location":"references/index.html#vsid-internal-code","title":"VSID internal code","text":"<p>Lists the various VSID agents and describes their respective use</p>"},{"location":"references/index.html#vsid-user-interface","title":"VSID user interface","text":"<p>Describes the different parts of the VSID user interface</p>"},{"location":"references/index.html#api-documentation","title":"API documentation","text":"<p>VoltScript Interface Designer Documentation contains API documentation including all libraries.</p>"},{"location":"references/index.html#specific-libraries","title":"Specific libraries","text":"<p>Libraries contained within VoltScript Interface Designer Documentation:</p> <ul> <li>baliConstants - Constants used by VSID</li> <li>baliCoreUtils - Core Utilities</li> <li>baliExceptions -  Minimal Exception Tracking</li> <li>baliListsCollections - Lists and Collections Classes</li> <li>baliStrings -  String Utilities</li> <li>baliUtils_nlsxBE - NotesLSX Back End Utilities</li> <li>baliUtils_nlsxUI - NotesLSX UI Utilities</li> <li>BSXdocumentationUtils - API Documentation UI Utilities</li> <li>BSXnotesUtils - API Documentation Notes Client Utilities</li> <li>BSXnotesUtilsUI - VSID UI Utilities</li> <li>BSXparsingUtils - Parsing Utilities</li> <li>DesignUtils - Design Element Utilities</li> <li>dxlUtilsBE - DXL Back End Utilities</li> <li>enhLogClassLite - \"Lite\" version of Enhanced Log Class</li> <li>FileResource - File Resource Tools</li> <li>LSXWizardUtils - Utility methods specifically using the LSX Wizard</li> <li>WindowsDLLutils - Windows DLL specific utilities</li> </ul>"},{"location":"references/index.html#documentation-and-source-code","title":"Documentation and source code","text":"<ul> <li>HCL Volt MX Go Documentation</li> <li>VoltScript<ul> <li>Documentation</li> </ul> </li> <li>VoltScript Collections<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Testing<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript JSON Converter<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Console Colors<ul> <li>Source code</li> </ul> </li> <li>VoltScript Volt MX Middleware<ul> <li>Documentation</li> </ul> </li> </ul>"},{"location":"references/index.html#support","title":"Support","text":"<p>To share information, ask questions, and learn about VoltScript Interface Designer, go to the Community.</p>"},{"location":"references/mainscreen.html","title":"VSID user interface","text":"<p>When you open the VoltScript Interface Designer (VSID), you are presented with a user interface having the following main screen:</p> <p></p>"},{"location":"references/mainscreen.html#left-navigation-pane","title":"Left navigation pane","text":"<p>The left navigation pane enables you to access the following areas:</p> <p>Script Extension Projects </p> <p>The main view of the application where you can create and access your VoltScript Extension (VSE) projects.</p> <p>Script Library Projects</p> <p>The view where you can create and access your VoltScript Library (VSS) projects.</p> <p>Logs</p> <p>The view containing any logging tracked during processing operations.</p> <p>Administration</p> <p>The section storing all configuration documents, such as Data Types, Keywords, and C/C++ Skeletons.</p> <p>Note</p> <p>Normally, you should not change any documents in the Administration section as doing so could adversely affect the performance of VSID. </p>"},{"location":"references/mainscreen.html#app-bar","title":"App bar","text":"<p>At the top, you have the app bar that includes action buttons, such as Projects and Class, to create the different parts of your VSE Project. The Generate Extension Files enables you to generate your C/C++ extension files for further work in your C/C++ IDE. The app bar also includes the Setup button, and the Help button for accessing documentation.</p>"},{"location":"references/vsid.html","title":"VSID internal code","text":""},{"location":"references/vsid.html#generate-agents","title":"Generate Agents","text":""},{"location":"references/vsid.html#api-documentation","title":"API Documentation","text":"<p>The agent generates API documentation for all project information in the VSID database. It processes all Script Extension Project and Script Library Project documents into an internal object model. It then merges generated output from that model with predefined template HTML content to produce HTML, CSS, and Javascript output files. The agent also produces a log with information about the processing and any warnings or errors that may have occurred. You can find the log in the Logs view. More log information is written to a text log file in the output API directory, when an exception occurs.</p> <p>The object model and many of the utilities needed to generate this API documentation are in the BSXdocumentationUtils library. Code for loading information from various Documents, such as Project, Class, Method, is in the BSXnotesUtils library. Code for generating logs is in the enhLogClassLite library. Other libraries are also used, but these are the three primary \"worker\" libraries used by this agent.  </p> <p>The predefined template HTML, CSS, and Javascript files are in the DESIGN of the VSID database, as File or CSS resources.  </p>"},{"location":"references/vsid.html#extension-project-files","title":"Extension Project Files","text":"<p>The agent generates the C/C++ source files needed to build a Script Extension Project. Unlike the other \"Generate XXX\" agents, this only runs on the selected Script Extension Project document and it's children. The output VSE directory can be specified using the Setup button in the Script Extension Projects view. Information from these documents is merged with predefined C/C++ Skeleton documents to produce the output. The agent also produces a log with information about the processing and any warnings or errors that may have occurred. You can find the log in the Logs view.</p> <p>The primary utilities needed to generate this output are in the LSXCodeGenerationScripts library. The predefined C/C++ Skeleton files used for this agent are in regular Notes documents in Administration \u2192 C/C++ Skeletons view.</p>"},{"location":"references/vsid.html#library-source-code-stubs","title":"Library Source Code Stubs","text":"<p>The agent generates VSS Source code stub files needed to build a Script Library project. It processes all Script Library Project documents into an internal object model, and then merges generated output from that model with predefined template VSS content to produce the VSS Script output files. The agent also produces a log with information about the processing and any warnings or errors that may have occurred. You can find this log in the Logs view. More log information is written to a text log file in the output API directory, when an exception occurs.</p> <p>The object model and many of the utilities needed to generate this API documentation are in the BSXdocumentationUtils library. Code for loading information from various Documents, such as Project, Class, Method, is in the BSXnotesUtils library. Code for generating the logs is in the enhLogClassLite library. Other libraries are also used, but these are the three primary \"worker\" libraries used by this agent.  </p> <p>The predefined template VSS files are in the DESIGN of the VSID database, as File or CSS resources.  </p>"},{"location":"references/vsid.html#tools-agents","title":"Tools Agents","text":""},{"location":"references/vsid.html#compute-with-form","title":"Compute with Form","text":"<p>The agent performs a <code>ComputeWithForm()</code> operation on all selected documents.</p>"},{"location":"references/vsid.html#fix-invalid-app-names","title":"Fix Invalid App Names","text":"<p>The agent corrects invalid Application name values in all selected documents. This is only necessary if project documents were manually copied in from a preexisting LSX Wizard database.</p>"},{"location":"references/vsid.html#generate-script-library-api-documentation","title":"Generate Script Library API Documentation","text":"<p>The utility agent allows a user to select an external Script Library file, such as <code>.lss</code> or <code>.vss</code>, and try to generate API documentation in a similar manner as the Generate API Documentation agent. Code for parsing the external Script Library content into the object model is in the BSXparsingUtils library. </p>"},{"location":"references/vsid.html#import-from-existing-lsx-wizard","title":"Import from Existing LSX Wizard","text":"<p>The agent queries the user for an existing LSX Wizard database, and generates documents in the current VSID database from the documents in the LSX Wizard database.  </p>"},{"location":"references/vsid.html#log-config","title":"Log Config","text":"<p>The agent opens the Log Configuration document for editing to enable a user to specify various logging configuration options.</p>"},{"location":"references/vsid.html#reset-ancestor-id-fields","title":"Reset Ancestor ID Fields","text":"<p>When copying child documents, such as Class, Method, Variable, to new parents, the various ancestor ID fields, such as <code>F_ProjectID</code>, <code>F_ClassID</code>, <code>F_TypeID</code>, are no longer valid. Running the agent on these selected documents resets them to the correct values.</p>"},{"location":"references/vsid.html#update-admin-docs-from-chosen-template","title":"Update Admin Docs From Chosen Template","text":"<p>Because some configuration information for the VSID application is stored in normal documents, such as C/C++ Skeletons, Keywords, DataTypes, this information needs to be updated after a design refresh from an updated template has occurred. The agent allows the user to select the appropriate VSID template and intelligently pulls in any updated information from the template documents.</p>"},{"location":"references/whatsnew.html","title":"What's new","text":"<p>The section provides information on the latest features, improvements, and resolved issues related to VoltScript Interface Designer.</p>"},{"location":"references/whatsnew.html#v100","title":"v1.0.0","text":"<ul> <li>First release version of VoltScript Interface Designer.</li> </ul>"},{"location":"topicguides/index.html","title":"Topic guides","text":"<p>Topic guides discuss and explain topics and concepts about VoltScript Interface Designer.</p> <ul> <li>VSEs and the VoltScript Interface Designer</li> <li>VSE design considerations</li> <li>Using VSID for VSEs</li> </ul>"},{"location":"topicguides/overview.html","title":"VSEs and the VoltScript Interface Designer","text":"<p>The topic helps you understand what a VoltScript Extension (VSE) is, why you want to create one, and how you use the VoltScript Interface Designer (VSID) to do so.</p>"},{"location":"topicguides/overview.html#what-is-vse","title":"What is VSE?","text":"<p>VSE stands for VoltScript Extension module. A VSE is a shared library of VoltScript classes. It's implemented as a DLL, or the shared-library equivalent on non-Windows platforms. The source programming language for a VSE is C++.</p> <p>A VSE is usable by the VoltScript language, which is an independent scripting language that can be run as a standalone executable, or as a part of the Foundry server.</p> <p>A VSE can be portable. If the source is conditionalized appropriately, a single-source VSE module can be compiled and run on multiple operating systems. The supported operating systems include Windows 32, Windows 64, and Linux.</p> <p>A VSE can also be sharable. A single loaded VSE can be accessed by multiple processes and execution threads. Thus, multiple instances of VoltScript can access the LSX simultaneously.</p>"},{"location":"topicguides/overview.html#what-is-vsid","title":"What is VSID?","text":"<p>VSID stands for VoltScript Interface Designer. VSID is a toolkit based on the original LSX Toolkit first produced by Lotus Development for the Lotus Notes/Domino platform and related Lotus products that supported LotusScript. That original toolkit has been updated and evolved to support VoltScript, and new functionality has also been added to support VoltScript Libraries in a similar fashion.</p> <p>The VSID includes:</p> <ul> <li>necessary VoltScript source files - These are principally header (.h) files that define the VSE API for the VSE builder</li> <li>C++ base class source code - This is intended for inclusion, unmodified, in your VSE sources</li> <li>Source code for VSE samples</li> <li>This documentation</li> </ul> <p>The supported operating systems for this release of VSID are:</p> <ul> <li>32bit Windows</li> <li>64bit Windows</li> <li>Linux</li> </ul>"},{"location":"topicguides/overview.html#why-create-a-vse","title":"Why create a VSE?","text":"<p>A VSE enables the C++ developer to script classes defined in a wide variety of applications.</p>"},{"location":"topicguides/overview.html#vse-defined-classes","title":"VSE-defined classes","text":"<p>A script in VoltScript can manipulate several kinds of classes. The first two kinds are:</p> <ul> <li>Classes defined within VoltScript itself - These \"native classes\" are the classes defined by the Class statements within a script.</li> <li>Some LotusScript back-end classes, such as from Notes/Domino</li> </ul> <p>A VSE provides a third kind of class that leverages the functionality of VoltScript. A VSE defines custom C++ classes using the published API of some other application, including possibly the API of an operating system. After loading the VSE by the VoltScript language engine, then:</p> <ul> <li>The classes can be registered with VoltScript in the same way as product classes.</li> <li>Scripts can manipulate these additional classes in the same way as the core classes.</li> </ul> <p>The language used for operations on these classes is the same VoltScript language, used in the same way and with the same meaning as for core VoltScript classes.</p> <p>In effect, VoltScript is being used to script a second application at the same time as the core language. The VSE provides an object model for some features of the scripted application, which is the second application.</p>"},{"location":"topicguides/overview.html#functions-in-a-vse-and-in-an-existing-dll","title":"Functions in a VSE and in an existing DLL","text":"<p>Not only classes, but also global functions and constants, can be defined in your VSE and registered in VoltScript so that a script can invoke them. The typical VSE contains one or more of these.</p> <p>However, if the functionality you need already exists as external functions in an available shared library written in C or in C++, then there may be no need to write and build a VSE. The following may be an alternative: </p> <p>In any script where you want to invoke such a function, you can use a VoltScript <code>Declare Function</code> statement to tell the VoltScript interpreter about the shared-library name and the function name, alias, and signature. Then the function is available thereafter to be used in the script. More commonly, you put the <code>Declare Function</code> statement in a script library and then put a <code>Use &lt;library&gt;</code> statement in any script where the function is needed.</p>"},{"location":"topicguides/overview.html#vse-development-environment","title":"VSE development environment","text":"<p>To develop and test a VSE, the development environment installed on your workstation must include the following:</p> <ul> <li>A standard C++ development environment for the development platform. This includes:<ul> <li>A supported C++ compiler for your platform. It's recommended to use MS Visual Studio, even the Community Edition is fine. For Linux, it's recommended to install G++.</li> <li>A C++ debugger</li> <li>The platform's linker</li> <li>A CMake utility</li> </ul> </li> <li>An installed VSID </li> <li>An installed VoltScript runtime environment</li> </ul>"},{"location":"topicguides/usingforvse.html","title":"Using VSID for VSEs","text":"<p>The VoltScript Interface Designer (VSID) consists of a Notes database and an LSX that helps you to create a VSE. VSID compiles information about the VSE you want to create, generating a near-complete set of buildable files.</p> <p>VSID is the tool you use in the first two steps of this four-step process that creates a VSE:</p> <ol> <li> <p>Create a VSE project, the set of all the VSE specifications.</p> <p>These specifications are documents in the Wizard's Notes database. You create them through the Wizard user interface.</p> </li> <li> <p>Generate VSE files. </p> <p>The VSID VSE does this when you invoke the action \"Generate VSE Files\" in the VSID UI.</p> </li> <li> <p>Edit the generated C++ source files using your C++ design environment.</p> </li> <li> <p>Compile the resulting source files to build the VSE.</p> <p>You can use one of the generated CMAKE files, the do_it batch file that invokes the C++ compiler on your workstation, or the VSID-generated Microsoft project file (.dsp).</p> <p>You can then test your VSE using the VoltScript runtime.</p> </li> </ol>"},{"location":"topicguides/usingforvse.html#special-features","title":"Special features","text":"<p>In this release of VSID, you can:</p> <ul> <li>Generate VSE source files from specifications in the VSID Notes database and edit them, then change the specifications and re-generate the files from the new specifications, without losing the results of the editing.</li> <li>Import VSE specifications from earlier releases of VSID or the VSE Toolkit.</li> <li>Edit VSE specifications at several levels in the Notes user interface, such as at the Project level for the complete VSE, by individual documents, or by fields within documents.</li> </ul>"},{"location":"topicguides/usingforvse.html#generating-vse-source-files","title":"Generating VSE source files","text":"<p>The command Generate Extension Files appears on the Actions menu in the VSE Projects view in the VSID application. When you invoke this action with any document in a selected project, it generates the VSE source files from the specifications in all the documents for that project.</p> <p>The complete set of files is generated each time. There is no partial file generation, even if some specifications are unchanged since the last generation. For a VSE of typical size, the generation takes a few seconds to create and write the files.</p> <p>The generated files are written in the directory <code>vse\\src\\&lt;vse_name&gt;</code>, where <code>&lt;vse_name&gt;</code> is the name specified in the Name field of the Project document for this VSE. In Windows, for example, they include these files:</p> <ul> <li> <p>Four files for each class defined in the VSE. If the class is named <code>&lt;cname&gt;</code>, the files are: </p> <ul> <li><code>&lt;cname&gt;.hpp</code></li> <li><code>&lt;cname&gt;.cpp</code></li> <li><code>i&lt;cname&gt;.cpp</code> </li> <li><code>i&lt;cname&gt;.tab</code></li> </ul> <p>Tip</p> <p>The leading <code>i</code> in the names, such as in <code>i&lt;cname&gt;.cpp</code>, stands for infrastructure. For more information, see Post-editing and tags.</p> </li> <li> <p><code>lsxsess.hpp</code> and <code>lsxsess.cpp</code> for the VSE's Session class</p> </li> <li>Project-level files <code>lsxapplx.h</code>, <code>lsxapplx.cpp</code>, <code>itextstr.h</code>, and <code>iguidfile.h</code></li> <li>CMAKE files, <code>.def</code> files, and batch files for use in building the VSE</li> <li>Library inclusion files, for example <code>libsresp.va2</code></li> </ul> <p>You can run the Generate Extension Files action on any of the sample VSE projects in the provided samples, and then examine the appropriate subdirectory of <code>vse\\src</code> to see these results.</p>"},{"location":"topicguides/usingforvse.html#post-editing-and-tags","title":"Post-editing and tags","text":"<p>After generating the VSE source files for a particular project, you edit some of these files to add your implementation to the generated stubs.</p> <p>You will routinely want to iterate through this three-step cycle:</p> <ol> <li>Re-specifying the VSE in the VSID application</li> <li>Generating VSE source files</li> <li>Editing the generated VSE source files</li> </ol> <p>For example, you may want to add a class to the VSE, or change a method's signature. When you complete any changes to the specifications in the VSID UI and run Generate Extension Files again, the contents of the directory <code>vse\\src\\&lt;vse_name&gt;</code> are completely replaced by this new round of generated files. To prevent losing the editing you did to the last preceding round of generated files, VSID uses a special mechanism. Certain of the files generated in any run contain tags to mark the locations in the file where you can post-edit. Any material that you insert at these marked locations is incorporated into the files generated in the next round. It's protected. VSID carries it over when writing the next version of the file.</p> <p>Every tag is in two parts, a \"begin tag\" and an \"end tag,\" in the form:</p> <p><code>//{{ VSE_AUTHOR_CODE_tagname</code> <code>//}}</code></p> <p>The begin and end tags just shown are literal strings except for <code>tagname</code>, which is the name of any particular tag. Code that you insert between the begin tag and the end tag is protected. Thus, to ensure that your edits are preserved, you should edit the generated files only between the tags.</p> <p>To acquaint yourself with this mechanism, browse through the files in the <code>vse\\src\\&lt;vse_name&gt;</code> directory for a sample VSE and look for this string:</p> <p><code>//{{ VSE_AUTHOR_CODE_</code></p> <p>You'll find that:</p> <ul> <li>The files <code>&lt;cname&gt;.hpp</code> and <code>&lt;cname&gt;.cpp</code> contain tags, where <code>&lt;cname&gt;</code> is the name of any class defined in the VSE. This includes the Session class automatically generated by VSID, represented by the files <code>lsxsess.hpp</code> and <code>lsxsess.cpp</code>.</li> <li><code>lsxapplx.h</code> and <code>lsxapplx.cpp</code> contain tags.</li> <li>There are never tags in any file whose filename is prefixed with <code>i</code>, lower-case letter \"i\" for infrastructure. For example, no tags are generated in <code>ilsxsess.cpp</code> or <code>ilsxsess.tab</code>.</li> </ul> <p>Of course, you can edit any VSID-generated source file at locations that aren't tagged, and you can edit any file that contains no tags, such as a file whose filename is prefixed with <code>i</code>.  However, such edits aren't protected and will be overwritten. The \"i\"-prefixed files are designed to need no editing.  </p> <p>Note</p> <p>Generate Extension Files backs up the current generation of files when regenerating. Therefore, unprotected edits to the current generation aren't completely lost. But they aren't merged into the new generation of files like protected edits.</p>"},{"location":"topicguides/usingforvse.html#tags-and-tagged-code-in-the-vse-source-files","title":"Tags and tagged code in the VSE source files","text":"<p>In the tag string <code>LSX_AUTHOR_CODE_&lt;tagname&gt;</code>, the <code>&lt;tagname&gt;</code> identifies the likely purpose of code that you will write at that tagged location. For example:</p> <ul> <li><code>LSX_AUTHOR_CODE_Include1</code> appears just before a standard set of <code>#include</code> statements near the beginning of <code>&lt;cname&gt;.hpp</code>. You would insert there any <code>#include</code> statements that should appear before the standard set.</li> <li><code>LSX_AUTHOR_CODE_Private_Internal</code> appears just after the \"private:\" declaration near the beginning of a class declaration in <code>&lt;cname&gt;.hpp</code>.</li> <li>Internal refers to the fact that these declarations are only used internally by your VSE, and not accessible from VoltScript.</li> </ul> <p>Three tags need special mention:</p> <p>In the generated code, every class inherits from the abstract class LSXBase, as shown in <code>&lt;cname&gt;.hpp</code> and <code>&lt;cname&gt;.cpp</code>. VSID doesn't support multiple inheritance. But these two tags enable you to specify one or more additional classes for cname to inherit from:</p> <ul> <li><code>LSX_AUTHOR_CODE_Additional_Base_Classes</code> in <code>&lt;cname&gt;.hpp</code> </li> <li><code>LSX_AUTHOR_CODE_Additional_Base_Class_Init1</code> in <code>&lt;cname&gt;.cpp</code></li> </ul> <p>You can initialize any variables by adding lines below this tag:</p> <ul> <li><code>LSX_AUTHOR_CODE_Internal_Member_Init1</code></li> </ul> <p>If the class contains any properties, they're initialized in VSID-generated lines immediately following the tag. You add your initializations next. Each of your initialization lines following the property lines must begin with a comma. Usually, an initialization line would contain a trailing comma; but VSID doesn't generate that comma on the last property variable initialized, since it's unknown whether anything is to follow.</p> <p>The set of VSID-generated tags is the same for every VSE, except that some tags are associated with a named property or method, and are based on the property or method name. Tags appear in the same approximate locations in the generated source files, again allowing for differences in the number and names of classes and their members.</p>"},{"location":"topicguides/usingforvse.html#personal-tags","title":"Personal tags","text":"<p>You can also define your own personal tags, writing them into the generated source files. When VSID regenerates files, it will not preserve the location of a personal tag, but comments out the code between the begin and end tags and pastes the result at the bottom of the file.</p> <p>When you create a personal tag, you need to follow these rules:</p> <ul> <li> <p>Any personal tag must have the same format as a Wizard-generated tag:</p> <p><code>//{{LSX_AUTHOR_CODE_mytagname</code></p> <p><code>//}}</code></p> </li> <li> <p><code>mytagname</code> must be unique: different from any VSID-generated tag and from any other personal tag</p> </li> <li>You can use a personal tag only in a file that contains VSID-generated tags</li> <li>These are the only files that VSID checks for the presence of tags when re-generating files</li> <li>You cannot have nested tags</li> </ul> <p>Most VSID-generated tags are empty: that is, there is no Wizard-generated code between the begin tag <code>//{{LSX_AUTHOR_CODE_tagname</code> and the end tag <code>//}}</code>. These are the exceptions:</p> <ul> <li>Method return values in any <code>&lt;cname&gt;.cpp</code>, following the begin tag <code>//{{LSX_AUTHOR_CODE_Method_&lt;method_name&gt;</code><ul> <li>These are just dummy values so that the newly generated code will compile.</li> </ul> </li> <li>Error-message code in <code>lsxapplx.h</code> and <code>lsxapplx.cpp</code>, following the begin tags <code>//{{LSX_AUTHOR_CODE_Error_Messages</code> and <code>//{{LSX_AUTHOR_CODE_Min_Error_Code</code><ul> <li>There VSID generates a couple of default error messages for you, and a minimum error-message code. You are free to change them, or to add your own.</li> </ul> </li> </ul> <p>In all other cases, you create protected code by simply adding lines between the line <code>//{{LSX_AUTHOR_CODE_tagname</code> and the end tag line <code>//}}</code>.</p>"},{"location":"topicguides/usingforvse.html#regenerating-vse-source-files","title":"Regenerating VSE source files","text":"<p>When you run the action Generate Extension Files in the VSID user interface, it checks for the existence of the target directory <code>vse\\src\\&lt;lsx_name&gt;</code>.</p> <ul> <li>If this directory doesn't exist, VSID creates the directory, generates the VSE source files, and writes them into it.</li> <li>If the directory exists, VSID assumes that the VSE source files have been previously generated. Then, the generation code runs a two-step process:<ul> <li>Back up the existing files to the subdirectory <code>vse\\src\\&lt;lsx_name&gt;\\backup</code>.</li> <li>VSID creates the backup subdirectory if it doesn't exist already. If it does exist, the new backups overwrite any existing contents. Only one level of backup is maintained.</li> </ul> </li> <li>Generate new source files into the directory, merging in the tagged code from the existing files.</li> </ul> <p>The generate-and-merge process works as follows:</p> <ul> <li>A validation routine in the VSID Wizard DLL checks the existing files in <code>vse\\src\\&lt;lsx_name&gt;</code> to verify that all the tags in those files are valid.<ul> <li>For instance, every begin tag must have an end tag. Also, tags may not be nested.</li> <li>Any errors found by the validation routine are reported to the user. The user must fix them before VSID generation will generate any code.</li> </ul> </li> <li>If a method, property, or event has been renamed in the VSE specifications, any tag name in any old file that uses this name is modified to use the new name.</li> <li>Each new file is generated based on the VSE specifications. The file is generated with tags in it. Each tag is empty or contains default code.</li> <li>For each tag, the tag contents from the old file are merged with the tag in the new file.<ul> <li>If a method, property, or event has been deleted, the corresponding tag contents from the old file are commented out and the commented material is pasted at the bottom of the new file.</li> </ul> </li> </ul>"},{"location":"topicguides/vsedesign.html","title":"VSE design considerations","text":"<p>As you design your VSE, you may want to keep these design considerations in mind.</p>"},{"location":"topicguides/vsedesign.html#the-object-model","title":"The object model","text":"<p>Before you can design a VSE that implements an abstract model of objects and object relationships, you have to specify that model itself. And before that model can be specified, you need to specify the real-world objects and relationships that you mean to approximate with the abstract object model. This is \"entity and relationship modeling\": creating the first statement of what it's in the real world that you want to automate in an object-oriented program.</p> <p>Some business operations of a typical company, for example, will involve aggregate objects usually called \"cost centers\" and \"workgroups\". </p> <p>These two kinds of real-world objects may be contained one within the other in the company, may be identical, or may be members of separate hierarchies with the same root. Although less likely, they may be completely unrelated. However, these two items are defined and related in the company, that needs to be understood before you can enter them faithfully into an abstract model.</p> <p>The real-world relationships that you model will depend also on the kind of information you want the entire system to produce. For example:</p> <ul> <li>If the operations environment is an assembly plant in a manufacturing company and you want to model the manufacturing costs, then you may need to see each subassembly as an aggregate of its component parts, each with a cost of its own.</li> <li>If on the other hand you want to model the flow of work in progress through the plant, then the defining information about a subassembly may be not its component parts and quantities (the bill of materials), but the set of higher-level assemblies in which this subassembly is a component. </li> </ul> <p>Creating the abstract model means making decisions like these about objects and their attributes.</p> <p>Note that this sort of modeling happens before designing your program. The result may be the model that the program will implement, or not. For example, suppose that in your company, workgroups and cost centers are the same operating units. But you think of certain attributes and operations for workgroups in your company, and other attributes and operations for cost centers. A model of all company operations can include these two kinds of objects, and for each, its attributes and operations. A VSE that implements the corresponding classes separately may be easier to understand and maintain than one in which a single class is used to represent both conceptual objects, together with the aggregate of all operations associated with either one. It's the VSE designer's choice to make, either implementation may serve its purposes better.</p> <p>In the eventual VSE program, the C++ code that defines classes must of course represent some coherent conceptual model of objects and their relationships. Further, when the VSE registers these classes with VoltScript, the resulting classes are treated as distinct classes in scripts.</p> <p>Note</p> <ul> <li>The preceding description is not related to your choice of whether to use the VSID compiler to generate C++ class-definition structures to be accessed by your VSE and used in the calls to VoltScript that register the classes. The class-definition input to VSID is one-to-one with the resulting class definitions in C++.</li> <li>The source-code example contents for VSEs in VSID are already realizations of simple conceptual object models. VSID doesn't help you directly with the design process of conceptualizing your real-world objects and designing the final object model that your VSE will implement. It only provides the tools to realize the final object model in code.</li> </ul>"},{"location":"topicguides/vsedesign.html#the-object-creation-model","title":"The object creation model","text":"<p>You must design the mechanism for creating objects of LSX classes. There are two basic styles of how to create an object of a particular class:</p> <ul> <li>The class definition has a New method for objects of that class. An object of the class is created by invoking the exposed New method.</li> <li>An object of a class is created by running a create method for that class on an object of its parent class. The parent class will be the direct parent of the given class.</li> </ul>"},{"location":"topicguides/vsedesign.html#instantiation-of-an-object-using-the-new-method","title":"Instantiation of an object using the New method","text":"<p>Suppose that the class definition of the class OutClass, say, exposes a New method. Then an example of the VoltScript language for creating a new object of class OutClass is:</p> <p><code>Dim XO As New OutClass</code></p> <p>This line of code does the following:</p> <ul> <li>It declares the variable XO whose type is the class OutClass</li> <li>It creates a new object of that class</li> <li>It stores in XO a reference to the new object</li> </ul>"},{"location":"topicguides/vsedesign.html#instantiation-of-an-object-using-its-creation-method-in-a-parent-class","title":"Instantiation of an object using its creation method in a parent class","text":"<p>Suppose that an object of the OutClass class is created by running its creation method on an object of a parent class. Then an example of the VoltScript language for creating a new object of class OutClass could be:</p> <p><code>XO = XS.CreateOutClass</code></p> <p>In this line of code:</p> <ul> <li>XS is a variable referring to an object of the parent class</li> <li>CreateOutClass is a method in the parent class</li> <li>CreateOutClass creates an object of the OutClass class</li> </ul> <p>One way to implement this model is to design the LSX classes such that:</p> <ul> <li>A Session class is parent of every other class; and </li> <li>For every derived class, the Session class contains a create method for objects of that derived class</li> </ul>"},{"location":"topicguides/vsedesign.html#the-data-model","title":"The data model","text":"<p>You need to consider what kinds of data structures to use to represent the data members of the classes in your model.</p> <ul> <li>VoltScript supports array variables and list variables, as well as scalar variables of various data types.</li> <li>VoltScript also implements the Variant data type.<ul> <li>This data type enables the user to create multi-level list and array structures. </li> <li>For example, VoltScript supports an array of arrays, which is an array variable whose members are themselves arrays.</li> </ul> </li> </ul> <p>You can declare and use the data members of your VSE classes as these data types and structures.</p>"},{"location":"topicguides/vsedesign.html#collection-classes","title":"Collection classes","text":"<p>A further way to structure your LSX class is to define and register it as a collection class.</p> <p>A collection class is a container of items that LotusScript can access directly in two ways:</p> <ul> <li>By indexing - This accesses an individual item in a collection.</li> <li>By the ForAll language iteration construct - This accesses every item in a collection.</li> </ul> <p>The allowable operations are to access the values, the properties, and the methods of an individual item or of every item in the collection.</p>"},{"location":"topicguides/vsedesign.html#expanded-classes","title":"Expanded classes","text":"<p>Define your VSE class as an expanded class if you want to omit the definition of one or more properties or methods when you register the class in VoltScript, and complete the class definition at runtime.</p> <p>At runtime, a script statement that refers to an unknown member of a registered class triggers a callback to the VSE with the message <code>LSI_ADTMSG_BINDMEMBER</code>. The VSE code responding to this callback must supply the appropriate property or method definition.</p> <p>This implementation of delayed binding allows you to design class definitions that vary depending on runtime conditions. To do this, you must register the class containing this property as an expanded class.</p>"},{"location":"topicguides/vsedesign.html#character-sets","title":"Character sets","text":"<p>You must determine what character set to use to represent VSE-maintained strings that must be passed to VoltScript.</p> <p>The VoltScript internal representation is UNICODE. However, an VSE or an embedding application can specify any of four \"string communication\" representations to VoltScript: </p> <ul> <li>The platform-native character set</li> <li>UNICODE</li> <li>LMBCS, or the Lotus Multi-Byte Character Set</li> <li>ASCII</li> </ul> <p>This means that a string will be presented to VoltScript in that representation. VoltScript is responsible for converting the string to UNICODE as needed for its own purposes. </p>"},{"location":"topicguides/vsedesign.html#multi-platform-design","title":"Multi-platform design","text":"<p>You need to decide whether to write the VSE for one platform or several. Although single-platform design allows you to write C++ source code to take advantage of known compiler idiosyncrasies, the resulting source code is not portable.</p> <p>In VSID, the platform-common code file <code>lsxcomm.cpp</code> is platform-independent. This file selects and includes a platform-specific header file. The selection criterion differentiates the platforms 32-bit Windows, 64-bit Windows, or Linux. The inclusion conditionalizes the compilation of the rest of <code>lsxcomm.cpp</code> for each platform.</p> <p>Each sample provided with VSID compiles for all platforms that support the sample. For example, note the subdirectories for the Intel platforms w32 or w64 under <code>lsx\\src\\Datatypes\\objs</code>. The compiler MAKE files instruct the compiler to output the object files in one of these directories, depending on the platform.</p>"},{"location":"topicguides/vsedesign.html#using-guids","title":"Using GUIDs","text":"<p>A GUID-style class identifier must be used for any class that a VoltScript client, such as a VSE, exposes to VoltScript.</p> <p>Your VSE should not use, for its classes, any GUID that's not in a range established as available for your use. Any other GUID might be used already, or in the future, by someone else, for a class exposed by some other application. Conflicting uses of a GUID can have unpredictable results. This is unlikely, since VoltScript will not allow a VSE to register a class that has the same GUID as an already-registered class.</p> <p>The GUIDs for your VSE classes are automatically generated by VSID when you create a new project. You can also generate your own by running the GUIDGEN or UUIDGEN utility directly, or by request to Microsoft. These GUIDs are guaranteed non-conflicting with GUIDs for any other classes.</p>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<p>Tutorials provide a hands-on introduction to how to use VoltScript Interface Designer.</p> <ul> <li>Installation and setup</li> <li>VSID - Invoice Library example</li> <li>VoltScript Extention Samples</li> </ul>"},{"location":"tutorials/invoicelibrarysample.html","title":"VoltScript Interface Designer - Invoice library example","text":"<p>This section introduces you to using the VoltScript Interface Designer (VSID) - Library feature through an example Library. In this case, the example is a simple library that's used to access and update an invoice. You can find the Library in the Invoice Library database (INVLIB.NSF).</p> <p>Please refer to the reference for the various forms found in the Library section.</p> <p>The Library feature of VSID helps you plan and design your classes for your project, and generate the starting \"skeleton\" code to begin your development. It's recommended that you create one VSID database per project.</p> <p>You can begin by creating the Project document. Open the Invoice Library database, and navigate to the Script Library Projects section. Here you'll find the Invoice project documents.</p> <p></p>"},{"location":"tutorials/invoicelibrarysample.html#invoice-project","title":"Invoice project","text":"<p>You can begin by building the Invoice Project document. This form is where you give your project a name, define the various options for your project, and define dependencies your project has on other libraries or extensions. In this case the Invoice is a Public, Base class with no external dependencies.</p> <p></p> <p>Now that you have a base Project document, begin laying out the classes. You can start by making your first Class, the Invoice class.</p>"},{"location":"tutorials/invoicelibrarysample.html#invoice-class","title":"Invoice class","text":"<p>The first class you'll create is your Invoice class. In this document, you give your class a name and indicate if your class is a Base or Derived class. A Derived class is one that's based on, or is derived from, another class. You usually do this to enhance a base class to better serve your needs and to add more functionality, while taking advantage of the properties, methods, and functionality provided by the \"parent\" class.</p> <p>In this case, your Invoice class is a Base class.</p> <p>You can also optionally add an example of how your class is called in the Code Sample area.</p> <p></p> <p>Note</p> <p>Once you save and close a Class document the first time, it automatically generates a <code>Sub New()</code> Method document. This is because all Classes are required to have a New() constructor, even if it's not used programmatically.</p> <p>Now that you have your class, add some properties.</p>"},{"location":"tutorials/invoicelibrarysample.html#invoice-properties","title":"Invoice properties","text":"<p>Your Invoice class is used to programmatically load an invoice as an object. Therefore, you need to represent the data stored in the invoice in your class. You do this using Property documents. For your invoice, you want to access the following information:</p> <ul> <li>CustomerID - the unique identifier for the customer</li> <li>CustomerName - the name of the customer</li> <li>InvoiceDate - the date the invoice was created</li> <li>InvoiceID - the ID of the invoice</li> <li>InvoiceTotal - the total amount of the invoice</li> </ul> <p>Take a look at a couple of these Property documents.</p>"},{"location":"tutorials/invoicelibrarysample.html#customerid","title":"CustomerID","text":"<p>The CustomerID property is a simple string value storing the unique ID of the customer. Therefore, you only need to provide the name of the property (CustomerID), and indicate that it's a String data type.</p> <p></p>"},{"location":"tutorials/invoicelibrarysample.html#invoicetotal","title":"InvoiceTotal","text":"<p>The InvoiceTotal property is used in your Invoice class to store the extended total amount of the invoice. However, since this is a computed value that should be derived from the total amount of the entries in your invoice, it should not be editable. Therefore, create a READ-ONLY property to compute and store this number.</p> <p></p> <p>You give the property the InvoiceTotal name, set the Read-Only attribute, and set the Data Type to Double so it can properly store the total. Once you generate your skeleton code, you could then write some VoltScript to compute this total based on the entries of the invoice.</p> <p>Now that you have the basics of your Invoice class built, you need some way to represent each individual entry, or row, within your Invoice. You do this by creating a second class, the InvoiceEntry class.</p>"},{"location":"tutorials/invoicelibrarysample.html#invoiceentry","title":"InvoiceEntry","text":"<p>In your Invoice, you'll have individual rows of items that comprise the Invoice order. You need a way to programmatically access these individual rows. You'll do this by creating an InvoiceEntry class. </p> <p>Now since your InvoiceEntry objects are a part of the overall Invoice, you'll make your InvoiceEntry class derived from the parent Invoice class. This allows you to access the properties and methods of the parent Invoice object from the InvoiceEntry object.</p> <p></p> <p>This class stores the following information about an individual Invoice row:</p> <ul> <li>Description - the name or description of the item</li> <li>SKU - the unique identifier of the item</li> <li>UnitPrice - the cost of a single item</li> <li>Quantity - the number of items ordered</li> <li> <p>ExtPrice - the extended price of the entry, which is the <code>UnitPrice X Quantity</code></p> <p>Note</p> <p>The ExtPrice property is READ-ONLY.</p> </li> </ul> <p></p>"},{"location":"tutorials/invoicelibrarysample.html#accessing-invoiceentry-objects","title":"Accessing InvoiceEntry Objects","text":"<p>You now have an Invoice class to represent an invoice, and you have a way to represent individual rows in your invoice using the InvoiceEntry class. But how do you create and access these individual rows? We'll do this using Methods from within your Invoice object.</p> <p>You need to be able to do three things:</p> <ul> <li>Add an Invoice Entry</li> <li>Delete an Invoice Entry</li> <li>Get an existing Invoice Entry</li> </ul> <p>Begin by creating a method for adding a new InvoiceEntry to your Invoice.</p>"},{"location":"tutorials/invoicelibrarysample.html#addentry-method","title":"AddEntry method","text":"<p>Create your new AddEntry method using the Method document. When creating a new InvoiceEntry object, provide all the relevant information contained within your InvoiceEntry object so that the properties are properly populated. Refer to the  AddEntry method:</p> <p></p> <p>After entering the name, indicate the Type of method you're adding, either a Sub or a Function. </p> <p>Note</p> <p>Subs and Functions are simply a grouped set of programmatic instructions that can be referenced and used by name. The only difference between a Sub and Function is that a Function returns a value while and a Sub doesn't. </p> <p>In this case, the AddEntry method is a Function. Since it's a Function, indicate the Return Type, which is in this case an InvoiceEntry object.</p> <p>Now you need to define the arguments for your method. These arguments will be a part of the signature of the method, or the name and parameters required to invoke this method. In this case, you're defining arguments that will be used to populate the properties of your InvoiceEntry. This includes SKU, UnitPrice, Quantity, and Description.</p> <p></p> <p>You also define the arguments' data types:</p> <ul> <li>SKU - String</li> <li>Quantity - Long</li> <li>Description - String</li> <li>UnitPrice - Double</li> </ul> <p>Note</p> <p>You do not need to pass the ExtendedPrice as a parameter, since it's read-only and will be computed based on the UnitPrice and Quantity.</p> <p>Once saved, you can see your new method's signature in the view.</p> <p></p> <p>Now that you have a way of adding a new InvoiceEntry, you need a way to access existing entries. You'll do this by creating a GetEntry method.</p>"},{"location":"tutorials/invoicelibrarysample.html#getentry-method","title":"GetEntry method","text":"<p>To access individual invoice entries, create the GetEntry method. Since the SKU is the way you uniquely identify the items in an invoice, you'll use that as your key for accessing the desired entry.</p> <p>Since you're returning an InvoiceEntry object, you'll set this method as a Function that returns an InvoiceEntry object.</p> <p></p> <p>Now that you have a way to create and access an InvoiceEntry, create a way to delete an entry.</p>"},{"location":"tutorials/invoicelibrarysample.html#deleteentry-method","title":"DeleteEntry method","text":"<p>You need a way to programmatically remove an entry from an invoice, so create a DeleteEntry method. Since you're deleting an entry and there's no need to return a value, so you'll define this method as a Sub. To identify which entry to remove, provide the SKU as the argument for your sub.</p> <p></p> <p>Now that you have an Invoice class to represent a customer's invoice, and InvoiceEntry class to represent individual rows in your Invoice, you need a place to store the individual InvoiceEntry objects that comprise your Invoice. So add a special property to your Invoice class.</p>"},{"location":"tutorials/invoicelibrarysample.html#list-invoiceentries-property","title":"List InvoiceEntries property","text":"<p>Class properties aren't limited to scalars and objects. They can also be arrays and lists. A list would be a perfect way to store and provide access to all the entries in your invoice. So, create a new property in your Invoice class called ListEntries.</p> <p></p> <p>After providing the name of your InvoiceEntries property, you need to make sure List is selected in the Attributes. Set the Data Type to InvoiceEntry, because this will be a list of InvoiceEntry objects. Since you use the SKU to uniquely identify your invoice entries, you need to provide it as a parameter.</p> <p>Now you need a way to actually load an invoice into memory, so create an OpenInvoice method.</p>"},{"location":"tutorials/invoicelibrarysample.html#openinvoice-method","title":"OpenInvoice Method","text":"<p>You need to have a way to load an existing invoice into an Invoice object, so create an OpenInvoice method.</p> <p></p> <p>In your method, you know that you want it to return an Invoice object, so you need to set it to be a Function with a Return Type of Invoice. Since you're using InvoiceID as your unique key for an Invoice, you need to add InvoiceID as an argument in your method signature.</p>"},{"location":"tutorials/invoicelibrarysample.html#invoicelist-list-variable","title":"InvoiceList List variable","text":"<p>One interesting thing about Library projects is that you can have some things defined in your Library, but that aren't a part of an actual class. Types, Variables, and Properties can all exist in a Library but outside of a class. If you're familiar with LotusScript, this is similar to the things you can put in the <code>(Declarations)</code> area of a Script Library.</p> <p>For your Invoice project, create a public Variable that can hold a list of Invoice objects. This way you could, say, load all the invoices for a particular customer into memory for easier access.</p> <p>To create this InvoiceList variable, you simply make sure you have the Project document selected in the view, then click the Variable action button.</p> <p></p> <p>Enter the name as InvoiceList, set the Scope to Public, and under Attributes select List then set the Data Type to Invoice, since this will be a list of Invoice objects.</p> <p></p>"},{"location":"tutorials/setup.html","title":"Installation and setup","text":"<p>Guides you through the procedures for installing and setting up VoltScript Interface Designer (VSID).</p>"},{"location":"tutorials/setup.html#download-vsid-repository","title":"Download VSID repository","text":"<ul> <li>Download the VSID repository from GitHub.  </li> </ul> <p>The VSID repository includes:</p> <ul> <li><code>vsid.ntf</code> - A VSID Notes template, which is a Notes-based database template (NTF), that is used to create VSID databases.</li> <li><code>vsidwizard.dll</code> - A VSID Wizard DLL used by VSID to compile and set up the VSE directory structure and files for your VSE on your computer.</li> <li><code>Invlib.nsf</code> - A VSID database containing sample documents used in the Invoice library example Tutorial</li> <li><code>VSESamples.zip</code> - An archive containing sample files used in the VoltScript Extension samples Tutorial</li> <li><code>vsid.nsf</code> - A VSID database containing documentation for the LotusScript libraries within VSID that generate VoltScript Extensions, VoltScript Source, and API documentation.  This database provides an example of the various types of documents (Project, Class, Method, etc.) used by VSID.  </li> <li>The On Disk Project containing VSID exported source (YAML files).  </li> <li>Additional documentation and instructions.  </li> </ul>"},{"location":"tutorials/setup.html#setup","title":"Setup","text":"<ol> <li>Place the <code>vsid.ntf</code> in your Notes data directory.</li> <li> <p>Place the <code>vsidwizard.dll</code> in your Notes program directory, or within a subdirectory therein. </p> <p>Note</p> <p>Make sure to note the full directory path where you placed the DLL. It is recommended to place it in a subdirectory, such as <code>&lt;notes program dir&gt;/lsx/bin</code>.</p> </li> </ol>"},{"location":"tutorials/setup.html#register-the-wizard-dll","title":"Register the wizard DLL","text":"<p>For your system to locate and use the wizard DLL, register the DLL with Windows by listing it in the Windows Registry. This can be accomplished by either:</p> <ul> <li> <p>Running the following command (using Administrator Privileges),  replacing <code>&lt;Wizard Path&gt;</code> with the correct full path to the wizard DLL location:</p> <pre><code>REG ADD HKLM\\Software\\Lotus\\Components\\LotusScriptExtensions\\2.0 /v lsxwizard /t REG_SZ /d \"&lt;Wizard Path&gt;\" /f \n</code></pre> </li> <li> <p>Using the Windows Registry Editor to edit the registry and create a new String Value with the name <code>lsxwizard</code> and the value of your full path the the wizard DLL location.  </p> </li> </ul> <p>Now that you have VSID set up on your system, you can either create a new VSID database or upgrade an old LSX Toolkit database to VSID.</p>"},{"location":"tutorials/vsesamples/index.html","title":"VoltScript Extension samples","text":"<p>LotusScript\u00ae features support for libraries, known as LotusScript\u00ae Extensions or LSX's. These C/C++ binaries provide new API's that are accessed through standard scripts. VoltScript continues this feature with extensions known as VoltScript Extensions or VSE's.</p> <p>HCL has developed a suite of VoltScript Extensions that provide VoltScript authors with many additional features not found in the base language. The VoltScript Interface Designer (VSID), evolved from the LSX Toolkit, creates new VSE's or imports existing LSX's. Once the design is complete, C++ skeleton code is generated, ready for implementation. This skeleton code handles communication with the VoltScript runtime, including registering the extension, receiving messages, and sending responses. Skeleton code compiles into a VSE that VoltScript can load, with methods taking no action when called.</p> <p>Sample LSX's were included with the LSX Toolkit. Several of these have been updated as VSE's and are included with VSID. Developers interested in developing a new VSE can reference these samples to learn how to implement a VSE from the generated starter code.</p> <p>These samples aren't intended as a \"best practice\" for implementing VSE's. Much of the code is not suitable for use in a production environment, without data sanitization, error checking, or robust and efficient data structures.</p>"},{"location":"tutorials/vsesamples/index.html#installation","title":"Installation","text":"<p>An archive named <code>VSE-Samples.zip</code> is included in the VSID distribution. This archive includes the source code for the sample VSE's and build scripts.</p> <p>Extract the contents of <code>VSE-Samples.zip</code> directly over the folder VSID is extracted to. No files will be overwritten. The samples include specially prepared build scripts and files, separate from the generated starter code. This samples archive depends on the common code included in the VSID distribution.</p>"},{"location":"tutorials/vsesamples/index.html#sample-vses","title":"Sample VSEs","text":""},{"location":"tutorials/vsesamples/index.html#customer","title":"Customer","text":"<p>Contains a simple <code>Customer</code> data class and a <code>CollCust</code> collection of <code>Customers</code>. The collection can be iterated through via the <code>ForAll</code> statement, and its contents accessed by index.</p>"},{"location":"tutorials/vsesamples/index.html#datatypes","title":"DataTypes","text":"<p>A VSE that features methods and properties of the native VoltScript data types. Methods provide examples of how to manipulate these data types as C++ objects and return them to the runtime.</p>"},{"location":"tutorials/vsesamples/index.html#lsxbeplus","title":"LSXBEPlus","text":"<p>A VSE that extends the LSXBE library from HCL Notes to show how to specialize some Notes back-end classes. In this example, <code>NotesDatabase</code> and <code>NotesView</code> are extended.</p>"},{"location":"tutorials/vsesamples/index.html#systemcheck","title":"SystemCheck","text":"<p>A VSE that uses Windows system calls to provide information about the host machine to the calling script through properties.</p>"},{"location":"tutorials/vsesamples/customer.html","title":"Customer sample VSE","text":"<p>Customer VSE features a simple class and a collection of this class with an internal linked list. The collection, <code>CollCust</code>, can be iterated using a <code>ForAll</code> loop statement in VoltScript, and its contents can be accessed by index like a typical list.</p>"},{"location":"tutorials/vsesamples/customer.html#classes","title":"Classes","text":""},{"location":"tutorials/vsesamples/customer.html#customer","title":"Customer","text":"<p>Represents a customer's contact information and account number, as might be used by a company. This is a simple data class with no additional author code added, using only the VSID generated code. Its properties can be manipulated. These properties can be accessed directly in VoltScript, or another part of the VSE via its <code>get</code> and <code>set</code> methods.</p>"},{"location":"tutorials/vsesamples/customer.html#collcust","title":"CollCust","text":"<p>Represents a collection of <code>Customer</code> objects, using an internal linked list. The head of the list is referenced through the <code>CustomerList</code> property, which is generated by VSID. A pointer to the current customer has been added to implement the <code>GetNextCustomer</code> and <code>GetPrevCustomer</code> methods. Helper methods to create new <code>Customer</code> objects have been added to implement the <code>OpenCustomers</code> method to populate the collection with the contents of a text file.</p> <p>This is a basic implementation that only uses the <code>LSXBase</code> linked list to navigate the contents of a collection. Other data structures, such as binary trees, heaps, maps, will have better performance, and should be chosen based on how the VSE will be used.</p>"},{"location":"tutorials/vsesamples/customer.html#managing-a-collection","title":"Managing a collection","text":"<p><code>OpenCustomers</code> reads the text file located at <code>FileName</code> and creates <code>Customer</code> objects based on the lines in this file. It uses the <code>CreateNewCustomer</code> helper method to create the new objects. <code>CreateNewCustomer</code> calls the <code>AddRef</code> method of the newly created <code>Customer</code> object, which informs the VoltScript runtime that the object is being actively used and should not be garbage-collected. If <code>AddRef</code> is not called, the runtime will automatically delete the object when it's no longer referenced in the script code, regardless of the state of the VSE.</p> <p><code>CloseCustomers</code> removes all <code>Customer</code> objects contained by the collection without destroying the <code>CollCust</code> object itself. For every <code>Customer</code> object, <code>DropRef</code> is called so that the runtime is aware the VSE is no longer using the object. <code>LSXDeleteList</code> is then called, which unlinks and deletes all <code>Customer</code> objects in the collection.</p>"},{"location":"tutorials/vsesamples/customer.html#navigating-a-collection","title":"Navigating a collection","text":"<p>The VoltScript runtime and the VSE services maintain references to all objects contained in a VSE. This includes support for linked lists of objects, such as those in a collection. Objects in a VSE can be affected by both the running VoltScript script and the VSE itself. Using the provided interfaces to interact with managed linked lists allows a VSE to manipulate objects and have the results available in the script afterwards.</p> <p><code>CollCust</code> provides three methods for manually walking through the collection in a script, <code>GetFirstCustomer</code>, <code>GetNextCustomer</code>, and <code>GetPrevCustomer</code>. These can only be used after calling <code>OpenCustomers</code>. The developer added member <code>m_CurrCustomer</code> is used to maintain the current place in the list. Refer to <code>src/Customer/CollCust.cpp</code> for commented source code and exact behavior.</p> <p>The <code>Customer</code> class, like other VSE classes, extends the <code>LSXBase</code> class, and has <code>GetNext</code> and <code>GetPrev</code> methods that return the next or previous object in the collection, returning <code>NULL</code> at the end of a list or if they're not part of a collection. <code>CollCust</code> uses these methods to navigate the list. The <code>LSXBase</code> methods return pointers or references to a <code>LSXBase</code>, so they will need to be cast to the appropriate class.</p> <p>For example, <code>GetNextCustomer</code> updates <code>m_CurrCustomer</code> to the next <code>Customer</code>, and returns a reference to this object. With no bounds checking or error handling, this could be done with two C++ statements:</p> <pre><code>m_CurrCustomer = (LSPTR(Customer))&amp;(m_CurrCustomer)-&gt;GetNext();\nreturn *m_CurrCustomer;\n</code></pre>"},{"location":"tutorials/vsesamples/customer.html#supporting-the-forall-loop","title":"Supporting the ForAll loop","text":"<p>VoltScript uses <code>CollectionOpen</code>, <code>CollectionNext</code>, and <code>CollectionClose</code> to iterate over the contents of a collection. These methods need to be implemented by a developer.</p> <p><code>CollectionOpen</code> sets arguments which are passed to later calls to <code>CollectionNext</code>. In <code>CollCust</code>, these are all set to the head of the internal linked list, <code>CustomerList</code>. Most of these arguments are used by the implementation, with <code>Found</code> terminating the loop when set to 0. <code>CollCust</code> only uses the <code>Last</code> argument to find the next object.</p> <p><code>CollectionNext</code> is called for every iteration of the loop, to fetch the next object in the collection. The candidate next object is found via the <code>GetNextPtr</code> method, and is returned to the runtime. If this object is <code>NULL</code>, the <code>Found</code> argument is set to 0, indicating that the end of the list has been reached.</p> <p><code>CollectionClose</code> is called when the loop terminates early to allow the VSE to perform any necessary cleanup. Nothing is required for this implementation.</p>"},{"location":"tutorials/vsesamples/customer.html#accessing-an-item-by-index","title":"Accessing an item by index","text":"<p>VoltScript uses the <code>CollectionItem</code> method to access specific indices of a collection. In VoltScript, an index can be any key, not just an integer. </p> <p><code>CollCust</code> implements this method by starting at the beginning of the linked list and searching every element until it finds a <code>Customer</code> object with the same <code>AccNumber</code> as the <code>Index</code> argument. The entire collection may need to be searched to find the desired index, resulting in poor performance with large collections.</p> <p>The <code>Found</code> argument is set to 1 if the index was found, and is 0 otherwise.</p>"},{"location":"tutorials/vsesamples/customer.html#test-script","title":"Test script","text":"<p>A test script for the <code>OpenCustomers</code> method is provided. This script is designed to be run from the root of the VSID installation folder. The <code>build-Customer</code> script with the <code>--test</code> flag can be used to run theses tests after a build. The script uses the <code>OpenCustomers</code> method to populate a CollCust object, then uses a <code>ForAll</code> loop to iterate over each of the Customers in the collection and print some selected properties.</p> <p>The test script opens the text file located at <code>src/Customer/test/voltscript/cust.txt</code> and parses the customer records in this file. Note that <code>OpenCustomers</code> method requires the data file opened to end with a blank line, and will crash if this line is not present.</p> <p>On Windows, the VSE can be built and the tests run with this command:</p> <pre><code>.\\build-Customer.bat --release --test\n</code></pre> <p>On Linux, the command is similar:</p> <pre><code>./build-Customer.sh --release --test\n</code></pre> <p>The <code>build-Customer.sh</code> script may need to be set as executable before it can run.</p> <p>The test script and its data are located in <code>src/Customer/test/voltscript/</code>.</p>"},{"location":"tutorials/vsesamples/datatypes.html","title":"DataTypes sample VSE","text":"<p>DataTypes VSE contains a single class with a selection of data types as both properties, arguments, and return types. This serves as an example of how native VoltScript data types can be manipulated in a VSE, even if they do not directly map to a C++ data type.</p>"},{"location":"tutorials/vsesamples/datatypes.html#classes","title":"Classes","text":""},{"location":"tutorials/vsesamples/datatypes.html#datatypes","title":"DataTypes","text":"<p>This VSE features examples of how to receive, manipulate, and return common data types from the VoltScript runtime. Refer to the method comments in <code>src/DataTypes/Datatypes.cpp</code> for details for a specific data type.</p>"},{"location":"tutorials/vsesamples/datatypes.html#initializing-currency-data-types","title":"Initializing currency data types","text":"<p>VSE's represent currency data types as structs, with <code>Hi</code> and <code>Lo</code> fields. These aren't automatically set in the generated constructors, and must be manually set by the author in the body of the constructors.</p>"},{"location":"tutorials/vsesamples/datatypes.html#manipulating-date-objects","title":"Manipulating Date objects","text":"<p><code>DateDemoFunction</code> provides an example of how to manipulate Date objects. These are represented in C++ with the <code>LSXDate</code> class, which provides getters and setters for the fields of time. The runtime's serialization methods are used by the VSE when returning a <code>LSXDate</code> back to the runtime. Note that a raw float cannot be used to initialize a <code>LSXDate</code> the way a <code>Date</code> object can in a script.</p>"},{"location":"tutorials/vsesamples/datatypes.html#raising-events-to-the-runtime","title":"Raising events to the runtime","text":"<p>A VSE can raise an event to the runtime for any reason a developer wishes, such as an error or warning. Events can be raised at any time during a script, even if the runtime is not currently making a call to the VSE.</p> <p>Events are first defined in VSID. <code>DataTypes</code> defines three events, <code>NumberArgsDemoEvent</code>, <code>StringArgsDemoEvent</code>, and <code>ObjectArgDemoEvent</code>. Each of these events take different arguments, as suggested by their names. All three events are raised by <code>RaisingEventsDemoMethod</code>. </p> <p>Events can be handled in a script through the <code>On Event</code> statement. For example, the <code>StringArgsDemoEvent</code> can be handled by the following sample sub:</p> <pre><code>Sub StringArgsDemoHandler(byValArg as String, byRefArg as String)\n    Print \"Arugment by value: \" &amp; byValArg &amp; \", argument by reference: \" &amp; byRefArg\nEnd Sub\n</code></pre> <p>In this sample, the first argument passed to <code>LSXRaiseEvent_StringArgsDemoEvent</code> maps to <code>byValArg</code>, and the second argument maps to <code>byRefArg</code>. The second argument is passed by reference - changes made to it in VoltScript will be visible in the VSE, though the sample code does nothing with the variable after raising the event. </p>"},{"location":"tutorials/vsesamples/datatypes.html#test-script","title":"Test script","text":"<p>An example test suite that uses the VoltScriptTesting library is included with this VSE. These files can be found in the <code>src/DataTypes/test/voltscript</code> folder, and the script can be run using the <code>build-DataTypes</code> scripts.</p> <p>On Windows, the VSE can be built and the tests run with this command:</p> <pre><code>.\\build-DataTypes.bat --release --test\n</code></pre> <p>On Linux, the command is similar:</p> <pre><code>./build-DataTypes.sh --release --test\n</code></pre> <p>The <code>build-DataTypes.sh</code> script may need to be set as executable before it can run.</p>"},{"location":"tutorials/vsesamples/lsxbeplus.html","title":"LSXBEPlus sample VSE","text":"<p>LSXBEPlus VSE is an example of how to extend the existing HCL Notes classes. Support for these classes in LotusScript\u00ae is provided via an LSX, LSXBE.</p> <p>Much of the behavior is additional processing before or after calling the underlying LSXBE classes. Constants and definitions for these classes can be found in the VSID source code, on the path <code>src/inc/lsxnotes.h</code>. The classes from the inherited LSX are all defined as the type <code>ForeignLSXObj</code>. \"Foreign\" refers to an external VSE, different from the current one.</p>"},{"location":"tutorials/vsesamples/lsxbeplus.html#classes","title":"Classes","text":""},{"location":"tutorials/vsesamples/lsxbeplus.html#notesdbplus","title":"NotesDbPlus","text":"<p>This class extends the <code>NotesDatabase</code> class. It holds an internal <code>NotesDatabase</code> reference., which is called when needed.</p>"},{"location":"tutorials/vsesamples/lsxbeplus.html#accessing-an-external-vse","title":"Accessing an external VSE","text":"<p>A number of classes are defined in LSXBE, with the ID constants for their properties and methods in the <code>lsxnotes.h</code> header file. These classes and their properties and methods can be accessed from inside a VSE through the <code>ForeignLSXObj</code> class, which provides an interface to access other VSE's or LSX's via the VoltScript runtime.</p> <p>For example, several methods require fetching a collection of all documents in the database. This is exposed as a property in the <code>NotesDatabase</code> class, named <code>AllDocuments</code>. <code>NotesDbPlus.cpp</code> accesses this property though the <code>GetProp</code> method of <code>ForeignLSXObj</code>, passing the property's ID constant:</p> <pre><code>NotesDocumentCollection DocColl = m_BaseNotesDatabase.GetProp(CNOTES_DBPROP_FINDALLDOCS).getForeignObject();\n</code></pre> <p>A VSE or LSX can define any number of new classes, which the calling class may have no knowledge of. As such, <code>GetProp</code> returns an extension of <code>LSXValue</code>, which represents a single object in the runtime. Depending on the type of the property, the appropriate getter for <code>LSXValue</code> should be called. <code>AllDocuments</code> is a <code>NotesDocumentCollection</code>, one of the classes defined in LSXBE, so its value is fetched via <code>getForeignObject</code>.</p> <p>After fetching a collection of all documents in the database, the first document can be fetched using the <code>GetFirstDocument</code> method in <code>NotesDocumentCollection</code>. The <code>CallFunction</code> method with the appropriate method ID constant is used:</p> <pre><code>NotesDocument CurrDoc = DocColl.CallFunction(CNOTES_DCMETH_GETFIRST).getForeignObject();\n</code></pre> <p><code>CallFunction</code> works similarly to <code>GetProp</code>, calling a method by its ID instead of accessing a property. As the <code>GetFirstDocument</code> returns a <code>NotesDocument</code> object, the <code>getForeignObject</code> method of the returned object is called to extract the <code>ForeignLSXObj</code> object.</p>"},{"location":"tutorials/vsesamples/lsxbeplus.html#notesviewplus","title":"NotesViewPlus","text":"<p>This class extends the <code>NotesView</code> class. Like <code>NotesDbPlus</code>, it has an internal reference of the class it's extending.</p>"},{"location":"tutorials/vsesamples/lsxbeplus.html#additional-constructor","title":"Additional constructor","text":"<p><code>GetViewPlus</code> in <code>NotesDbPlus</code> needs to construct a <code>NotesViewPlus</code> object with a different container object than usual. Refer to the comments for <code>GetViewPlus</code> in <code>src/LSXBEPlus/NotesDbPlus.cpp</code> for more details:</p> <p>When we specified the NotesView class in VSID, we declared the container class to be \"default\" (in fact, the Session object). We didn't specify the container as NotesDbPlus because we wanted the script writer to be able to access NotesViewPlus objects without needing a NotesDbPlus object. </p> <p>The generated constructor contains code (in the base class) to add the new object to the Session's list of contained objects. However, in this case where the NotesDbPlus object is creating the NotesViewPlus object, we would really have this be the container object.</p> <p>Since the code was not generated that way, we need to add a new constructor to the NotesViewPlus class which will add itself to the right list, create an internal data member in this class to hold the list (do not forget to initialize it in the constructor) and create functions for manipulating this list that can be called by the NotesViewPlus class.</p> <p>We also need to add code to the NotesViewPlus' destructor to remove itself from this list when the object is destroyed, and code to this objects destructor to destroy the list and it's elements when it's destroyed.</p>"},{"location":"tutorials/vsesamples/systemcheck.html","title":"SystemCheck sample VSE","text":"<p>SystemCheck VSE demonstrates how a Windows system calls can be used to provide information to a calling VoltScript script, which is not normally available. This VSE will not build or run on Linux or other platforms.</p>"},{"location":"tutorials/vsesamples/systemcheck.html#classes","title":"Classes","text":""},{"location":"tutorials/vsesamples/systemcheck.html#systeminfo","title":"SystemInfo","text":"<p><code>SystemInfo</code> features two methods that populate its properties. <code>DiskCheck</code> queries Windows for information about the disk drives on the system. <code>SystemCheck</code> queries Windows for information the processor, version of Windows, and physical memory.</p> <p>This information is available via the <code>SystemInfo</code> properties. There are too many statistics to return in a single object, and a script may only be interested in a few of them. Providing information through properties gives a script flexibility in how and where this information is used. A script could use the remaining free space to start a backup transfer of files, change behavior based on the operating system, or print multiple statistics in a single statement.</p>"},{"location":"tutorials/vsesamples/systemcheck.html#test-script","title":"Test script","text":"<p>A test script for <code>SystemInfo</code> is provided. It calls <code>DiskCheck</code> and <code>SystemCheck</code>, then prints the determined information.</p> <p>On Windows, the VSE can be built and the test script run with this command:</p> <pre><code>.\\build-SystemCheck.bat --release --test\n</code></pre> <p>The test script is located on <code>src/SystemCheck/test/voltscript/SystemCheck.vss</code>.</p>"}]}